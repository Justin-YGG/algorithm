---
title: "Agda by Example: λ-calculus"
date: 2013-08-10
tags:
- post
- talk
---

<p><strong>Update</strong>: I gave a talk at NY Haskell following this blogpost, although I didn’t manage to talk about everything:</p>
<div class="yt">
<iframe src="//player.vimeo.com/video/77168227" width="600" height="337" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>
</iframe>
</div>
<hr />
<p>In the <a href="../posts/AgdaSort.html">previous Agda example</a> we saw how we can approach the task of verifying a sorting function. This time, we are going to write a type checker for the simply typed λ-calculus, plus a simple optimization on said terms that we will prove correct. As in the other post the bulk of the thinking has been done by other people. The type checking is a modified version of an example given in <a href="http://strictlypositive.org/view.ps.gz"><em>The View from the Left</em></a> by Conor McBride and James McKinna,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> while the optimisation is inspired from a talk given by Adam Chlipala at POPL 2013—his Coq book <a href="http://adam.chlipala.net/cpdt/"><em>Certified Programming with Dependent Types</em></a> contains many similar examples.</p>
<p>Let’s get started.</p>
<h2 id="useful-imports">Useful imports <a href="#useful-imports" class="section-link">#</a></h2>
<pre class="Agda"><code><a name="1335" class="Markup"></a><a name="1347">
</a><a name="1348" class="Keyword">module</a><a name="1354"> </a><a name="1355" href="#1" class="Module">Lambda</a><a name="1361"> </a><a name="1362" class="Keyword">where</a><a name="1367">

</a><a name="1369" class="Keyword">open</a><a name="1373"> </a><a name="1374" class="Keyword">import</a><a name="1380"> </a><a name="1381" class="Module">Data.Nat</a><a name="1389"> </a><a name="1390" class="Keyword">using</a><a name="1395"> </a><a name="1396" class="Symbol">(</a><a name="1397" class="Datatype">ℕ</a><a name="1398" class="Symbol">;</a><a name="1399"> </a><a name="1400" class="InductiveConstructor">zero</a><a name="1404" class="Symbol">;</a><a name="1405"> </a><a name="1406" class="InductiveConstructor">suc</a><a name="1409" class="Symbol">;</a><a name="1410"> </a><a name="1411" class="Primitive Operator">_+_</a><a name="1414" class="Symbol">;</a><a name="1415"> </a><a name="1416" class="Function Operator">_≤?_</a><a name="1420" class="Symbol">;</a><a name="1421"> </a><a name="1422" class="Function Operator">_≥_</a><a name="1425" class="Symbol">)</a><a name="1426">
</a><a name="1427" class="Keyword">open</a><a name="1431"> </a><a name="1432" class="Keyword">import</a><a name="1438"> </a><a name="1439" class="Module">Data.Fin</a><a name="1447"> </a><a name="1448" class="Keyword">using</a><a name="1453"> </a><a name="1454" class="Symbol">(</a><a name="1455" class="Datatype">Fin</a><a name="1458" class="Symbol">;</a><a name="1459"> </a><a name="1460" class="InductiveConstructor">zero</a><a name="1464" class="Symbol">;</a><a name="1465"> </a><a name="1466" class="InductiveConstructor">suc</a><a name="1469" class="Symbol">;</a><a name="1470"> </a><a name="1471" class="Function">toℕ</a><a name="1474" class="Symbol">)</a><a name="1475">
</a><a name="1476" class="Keyword">open</a><a name="1480"> </a><a name="1481" class="Keyword">import</a><a name="1487"> </a><a name="1488" class="Module">Data.List</a><a name="1497"> </a><a name="1498" class="Keyword">using</a><a name="1503"> </a><a name="1504" class="Symbol">(</a><a name="1505" class="Datatype">List</a><a name="1509" class="Symbol">;</a><a name="1510"> </a><a name="1511" class="InductiveConstructor">[]</a><a name="1513" class="Symbol">;</a><a name="1514"> </a><a name="1515" class="InductiveConstructor Operator">_∷_</a><a name="1518" class="Symbol">;</a><a name="1519"> </a><a name="1520" class="Function">length</a><a name="1526" class="Symbol">)</a><a name="1527">
</a><a name="1528" class="Keyword">open</a><a name="1532"> </a><a name="1533" class="Keyword">import</a><a name="1539"> </a><a name="1540" class="Module">Data.Vec</a><a name="1548"> </a><a name="1549" class="Keyword">using</a><a name="1554"> </a><a name="1555" class="Symbol">(</a><a name="1556" class="Datatype">Vec</a><a name="1559" class="Symbol">;</a><a name="1560"> </a><a name="1561" class="InductiveConstructor">[]</a><a name="1563" class="Symbol">;</a><a name="1564"> </a><a name="1565" class="InductiveConstructor Operator">_∷_</a><a name="1568" class="Symbol">;</a><a name="1569"> </a><a name="1570" class="Function">lookup</a><a name="1576" class="Symbol">)</a><a name="1577">
</a><a name="1578" class="Keyword">open</a><a name="1582"> </a><a name="1583" class="Keyword">import</a><a name="1589"> </a><a name="1590" class="Module">Relation.Binary.PropositionalEquality</a><a name="1627"> </a><a name="1628" class="Keyword">using</a><a name="1633"> </a><a name="1634" class="Symbol">(</a><a name="1635" class="Datatype Operator">_≡_</a><a name="1638" class="Symbol">;</a><a name="1639"> </a><a name="1640" class="InductiveConstructor">refl</a><a name="1644" class="Symbol">;</a><a name="1645"> </a><a name="1646" class="Function">cong</a><a name="1650" class="Symbol">;</a><a name="1651"> </a><a name="1652" class="Function">cong₂</a><a name="1657" class="Symbol">)</a><a name="1658">
</a><a name="1659" class="Keyword">open</a><a name="1663"> </a><a name="1664" class="Keyword">import</a><a name="1670"> </a><a name="1671" class="Module">Relation.Nullary</a><a name="1687"> </a><a name="1688" class="Keyword">using</a><a name="1693"> </a><a name="1694" class="Symbol">(</a><a name="1695" class="Datatype">Dec</a><a name="1698" class="Symbol">;</a><a name="1699"> </a><a name="1700" class="InductiveConstructor">yes</a><a name="1703" class="Symbol">;</a><a name="1704"> </a><a name="1705" class="InductiveConstructor">no</a><a name="1707" class="Symbol">)</a><a name="1708">
</a><a name="1709" class="Keyword">open</a><a name="1713"> </a><a name="1714" class="Keyword">import</a><a name="1720"> </a><a name="1721" class="Module">Function</a><a name="1729"> </a><a name="1730" class="Keyword">using</a><a name="1735"> </a><a name="1736" class="Symbol">(</a><a name="1737" class="Function Operator">_∘_</a><a name="1740" class="Symbol">;</a><a name="1741"> </a><a name="1742" class="Function Operator">_$_</a><a name="1745" class="Symbol">)</a><a name="1746">
</a><a name="1747" class="Keyword">open</a><a name="1751"> </a><a name="1752" class="Keyword">import</a><a name="1758"> </a><a name="1759" class="Module">Data.Product</a><a name="1771">
</a></code></pre>
<p>After the module declaration, we include some useful modules from the <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.StandardLibrary">Agda standard library</a>:</p>
<ul>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Data.Nat.html"><code>Data.Nat</code></a> defines natural numbers.</p></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Data.Fin.html"><code>Data.Fin</code></a> defines an inductive families to represent the type of all numbers less than a given number. For instance <code>Fin 3</code> will be inhabited by <code>0</code>, <code>1</code>, and <code>2</code>. Another interpretation is that <code>Fin n</code> is the type inhabited by <code>n</code> elements.</p></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Data.List.html"><code>Data.List</code></a>, predictably, defines finite lists.</p></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Data.Vec.html"><code>Data.Vec</code></a> defines lists indexed by their length. This allows, for example, for safe indexing of elements.</p></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Relation.Binary.PropositionalEquality.html"><code>Relation.Binary.PropositionalEquality</code></a> defines propositional equality as <a href="../posts/AgdaSort.html#propositional-equality">presented</a> in the previous post. <code>cong₂</code> is the two-argument version of <code>cong</code>.</p></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Relation.Nullary.html#1"><code>Relation.Nullary</code></a> defines a type for decidable relations, <code>Dec</code>:</p>
<pre><code>  data Dec (P : Set) : Set where
    yes : ( p :   P) → Dec P
    no  : (¬p : ¬ P) → Dec P</code></pre></li>
<li><p><a href="http://www.cse.chalmers.se/~nad/listings/lib-0.7/Function.html"><code>Function</code></a> exports some common utilities regarding functions that should be familiar to the Haskell programmer, such as function composition (<code>_∘_</code>) and explicit application (<code>_$_</code>).</p></li>
</ul>
<h2 id="simple-types-and-raw-terms">Simple types and raw terms <a href="#simple-types-and-raw-terms" class="section-link">#</a></h2>
<p>The language we are going to define is a simple <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed λ-calculus</a>. The types for our language will be of two kinds: natural numbers and functions (arrow types):</p>
<pre class="Agda"><code><a name="3766" class="Markup"></a><a name="3778">
</a><a name="3779" class="Keyword">infixr</a><a name="3785"> </a><a name="3786" class="Number">30</a><a name="3788"> </a><a name="3789" href="#3830" class="InductiveConstructor Operator">_⇒_</a><a name="3792">
</a><a name="3793" class="Keyword">data</a><a name="3797"> </a><a name="3798" href="#3798" class="Datatype">Type</a><a name="3802"> </a><a name="3803" class="Symbol">:</a><a name="3804"> </a><a name="3805" class="PrimitiveType">Set</a><a name="3808"> </a><a name="3809" class="Keyword">where</a><a name="3814">
  </a><a name="3817" href="#3817" class="InductiveConstructor">nat</a><a name="3820"> </a><a name="3821" class="Symbol">:</a><a name="3822"> </a><a name="3823" href="#3798" class="Datatype">Type</a><a name="3827">
  </a><a name="3830" href="#3830" class="InductiveConstructor Operator">_⇒_</a><a name="3833"> </a><a name="3834" class="Symbol">:</a><a name="3835"> </a><a name="3836" href="#3798" class="Datatype">Type</a><a name="3840"> </a><a name="3841" class="Symbol">→</a><a name="3842"> </a><a name="3843" href="#3798" class="Datatype">Type</a><a name="3847"> </a><a name="3848" class="Symbol">→</a><a name="3849"> </a><a name="3850" href="#3798" class="Datatype">Type</a><a name="3854">
</a></code></pre>
<p>We will use <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> to represent bound variables, where <code>n</code> represents the variable bound by the <code>n</code>-th <code>λ</code> going towards the top of the term. For example, using an Haskell notation for <code>λ</code>s, we will have that</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Named</th>
<th style="text-align: left;">de Bruijn</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>λx → x</code></td>
<td style="text-align: left;"><code>λ 1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>λx → λy → x</code></td>
<td style="text-align: left;"><code>λ λ 2</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>λx → λy → λz → x z (y z)</code></td>
<td style="text-align: left;"><code>λ λ λ 3 1 (2 1)</code></td>
</tr>
</tbody>
</table>
<p>and so on. de Bruijn notation is a terrible device for humans to use directly, but it is often more convenient when dealing with terms mechanically. When parsing a language it is easy to go from names to nameless, so that we can have the best of both worlds.</p>
<p>Thus we will have:</p>
<pre class="Agda"><code><a name="4669" class="Markup"></a><a name="4681">
</a><a name="4682" class="Keyword">infixl</a><a name="4688"> </a><a name="4689" class="Number">80</a><a name="4691"> </a><a name="4692" href="#7270" class="InductiveConstructor Operator">_·_</a><a name="4695">
</a><a name="4696" class="Keyword">data</a><a name="4700"> </a><a name="4701" href="#4701" class="Datatype">Syntax</a><a name="4707"> </a><a name="4708" class="Symbol">:</a><a name="4709"> </a><a name="4710" class="PrimitiveType">Set</a><a name="4713"> </a><a name="4714" class="Keyword">where</a><a name="4719">
  </a><a name="4722" class="Comment">-- A variable, the ℕ being a de Bruijn index.</a><a name="4767">
  </a><a name="4770" href="#4770" class="InductiveConstructor">var</a><a name="4773"> </a><a name="4774" class="Symbol">:</a><a name="4775"> </a><a name="4776" class="Datatype">ℕ</a><a name="4777"> </a><a name="4778" class="Symbol">→</a><a name="4779"> </a><a name="4780" href="#4701" class="Datatype">Syntax</a><a name="4786">
  </a><a name="4789" class="Comment">-- A number literal.</a><a name="4809">
  </a><a name="4812" href="#4812" class="InductiveConstructor">lit</a><a name="4815"> </a><a name="4816" class="Symbol">:</a><a name="4817"> </a><a name="4818" class="Datatype">ℕ</a><a name="4819"> </a><a name="4820" class="Symbol">→</a><a name="4821"> </a><a name="4822" href="#4701" class="Datatype">Syntax</a><a name="4828">
  </a><a name="4831" class="Comment">-- Addition.</a><a name="4843">
  </a><a name="4846" href="#4846" class="InductiveConstructor Operator">_⊕_</a><a name="4849"> </a><a name="4850" class="Symbol">:</a><a name="4851"> </a><a name="4852" href="#4701" class="Datatype">Syntax</a><a name="4858"> </a><a name="4859" class="Symbol">→</a><a name="4860"> </a><a name="4861" href="#4701" class="Datatype">Syntax</a><a name="4867"> </a><a name="4868" class="Symbol">→</a><a name="4869"> </a><a name="4870" href="#4701" class="Datatype">Syntax</a><a name="4876">
  </a><a name="4879" class="Comment">-- Function application.</a><a name="4903">
  </a><a name="4906" href="#4906" class="InductiveConstructor Operator">_·_</a><a name="4909"> </a><a name="4910" class="Symbol">:</a><a name="4911"> </a><a name="4912" href="#4701" class="Datatype">Syntax</a><a name="4918"> </a><a name="4919" class="Symbol">→</a><a name="4920"> </a><a name="4921" href="#4701" class="Datatype">Syntax</a><a name="4927"> </a><a name="4928" class="Symbol">→</a><a name="4929"> </a><a name="4930" href="#4701" class="Datatype">Syntax</a><a name="4936">
  </a><a name="4939" class="Comment">-- Lambda abstraction, the type indicates the type of the argument: no</a><a name="5009">
  </a><a name="5012" class="Comment">-- type inference here.</a><a name="5035">
  </a><a name="5038" href="#5038" class="InductiveConstructor">lam</a><a name="5041"> </a><a name="5042" class="Symbol">:</a><a name="5043"> </a><a name="5044" href="#3798" class="Datatype">Type</a><a name="5048"> </a><a name="5049" class="Symbol">→</a><a name="5050"> </a><a name="5051" href="#4701" class="Datatype">Syntax</a><a name="5057"> </a><a name="5058" class="Symbol">→</a><a name="5059"> </a><a name="5060" href="#4701" class="Datatype">Syntax</a><a name="5066">
</a></code></pre>
<h2 id="typed-terms-and-type-checking">Typed terms, and type checking <a href="#typed-terms-and-type-checking" class="section-link">#</a></h2>
<p>Our λ-calculus has a very unsurprising type system. Typing judgements will be done in a context, holding the types of the abstracted variables. Calling the context <code>Γ</code>, we can give typing judgements for our syntax:</p>
<div class="center-image">
<img src="../assets/images/lambda-typ.png" title="fig:" alt="The type system for our language" />
</div>
<p>For those unfamiliar with typing rules like the ones above, they can be read as “given what’s above the bar, what’s below holds”. In our case we have judgements of the form <code>Γ ⊢ t : τ</code>, which can be read as “In context <code>Γ</code>, term <code>t</code> has type <code>τ</code>”.</p>
<p><code class="sc">Lit</code> says that number literals have type <code>nat</code>. <code class="sc">Add</code> says that given two terms of type <code>nat</code>, we can add them together yielding another term of type <code>nat</code>. <code class="sc">Var</code> says that given a variable we can get its type by looking it up in the context—we haven’t defined what a context is but we will soon. <code class="sc">App</code> says that given a function of type <code>τ ⇒ σ</code> we can apply it to a term of type <code>τ</code> to get a term of type <code>σ</code>. Finally, if we have a term <code>t : τ</code> in a context with <code>σ</code> “at its head”, we can form a function of type <code>σ ⇒ τ</code>, typed in the context with <code>σ</code> removed (<code class="sc">Lam</code>).</p>
<p>Now, taking advantage of Agda’s facilities, we can define a <code>Term</code> data type to represent terms together with their type—a <code>Term</code> will essentially include a derivation that its type is valid.</p>
<p>We will represent the context as a <code>Vec</code> containing <code>Type</code>s. The fact that <code>Vec</code> carry their length at the type is useful, since it will indicate how many variables are in scope, and thus what the largest de Bruijn index is.</p>
<pre class="Agda"><code><a name="6791" class="Markup"></a><a name="6803">
</a><a name="6804" href="#6804" class="Function">Ctx</a><a name="6807"> </a><a name="6808" class="Symbol">:</a><a name="6809"> </a><a name="6810" class="Datatype">ℕ</a><a name="6811"> </a><a name="6812" class="Symbol">→</a><a name="6813"> </a><a name="6814" class="PrimitiveType">Set</a><a name="6817">
</a><a name="6818" href="#6804" class="Function">Ctx</a><a name="6821"> </a><a name="6822" class="Symbol">=</a><a name="6823"> </a><a name="6824" class="Datatype">Vec</a><a name="6827"> </a><a name="6828" href="#3798" class="Datatype">Type</a><a name="6832">
</a></code></pre>
<p>A type checked <code>Term</code> will be parametrised over a context <code>Γ</code> of some length <code>n</code>. Moreover, it will be indexed by its type. The type is an index because different constructors will be typed differently, just like in the typing derivations.</p>
<pre class="Agda"><code><a name="7088" class="Markup"></a><a name="7100">
</a><a name="7101" class="Keyword">data</a><a name="7105"> </a><a name="7106" href="#7106" class="Datatype">Term</a><a name="7110"> </a><a name="7111" class="Symbol">{</a><a name="7112" href="#7112" class="Bound">n</a><a name="7113" class="Symbol">}</a><a name="7114"> </a><a name="7115" class="Symbol">(</a><a name="7116" href="#7116" class="Bound">Γ</a><a name="7117"> </a><a name="7118" class="Symbol">:</a><a name="7119"> </a><a name="7120" href="#6804" class="Function">Ctx</a><a name="7123"> </a><a name="7124" href="#7112" class="Bound">n</a><a name="7125" class="Symbol">)</a><a name="7126"> </a><a name="7127" class="Symbol">:</a><a name="7128"> </a><a name="7129" href="#3798" class="Datatype">Type</a><a name="7133"> </a><a name="7134" class="Symbol">→</a><a name="7135"> </a><a name="7136" class="PrimitiveType">Set</a><a name="7139"> </a><a name="7140" class="Keyword">where</a><a name="7145">
  </a><a name="7148" href="#7148" class="InductiveConstructor">var</a><a name="7151"> </a><a name="7152" class="Symbol">:</a><a name="7153"> </a><a name="7154" class="Symbol">∀</a><a name="7155"> </a><a name="7156" class="Symbol">{</a><a name="7157" href="#7157" class="Bound">τ</a><a name="7158" class="Symbol">}</a><a name="7159"> </a><a name="7160" class="Symbol">(</a><a name="7161" href="#7161" class="Bound">v</a><a name="7162"> </a><a name="7163" class="Symbol">:</a><a name="7164"> </a><a name="7165" class="Datatype">Fin</a><a name="7168"> </a><a name="7169" href="#7112" class="Bound">n</a><a name="7170" class="Symbol">)</a><a name="7171"> </a><a name="7172" class="Symbol">→</a><a name="7173"> </a><a name="7174" href="#7157" class="Bound">τ</a><a name="7175"> </a><a name="7176" class="Datatype Operator">≡</a><a name="7177"> </a><a name="7178" class="Function">lookup</a><a name="7184"> </a><a name="7185" href="#7161" class="Bound">v</a><a name="7186"> </a><a name="7187" href="#7116" class="Bound">Γ</a><a name="7188"> </a><a name="7189" class="Symbol">→</a><a name="7190"> </a><a name="7191" href="#7106" class="Datatype">Term</a><a name="7195"> </a><a name="7196" href="#7116" class="Bound">Γ</a><a name="7197"> </a><a name="7198" href="#7157" class="Bound">τ</a><a name="7199">
  </a><a name="7202" href="#7202" class="InductiveConstructor">lit</a><a name="7205"> </a><a name="7206" class="Symbol">:</a><a name="7207"> </a><a name="7208" class="Datatype">ℕ</a><a name="7209"> </a><a name="7210" class="Symbol">→</a><a name="7211"> </a><a name="7212" href="#7106" class="Datatype">Term</a><a name="7216"> </a><a name="7217" href="#7116" class="Bound">Γ</a><a name="7218"> </a><a name="7219" href="#3817" class="InductiveConstructor">nat</a><a name="7222">
  </a><a name="7225" href="#7225" class="InductiveConstructor Operator">_⊕_</a><a name="7228"> </a><a name="7229" class="Symbol">:</a><a name="7230"> </a><a name="7231" href="#7106" class="Datatype">Term</a><a name="7235"> </a><a name="7236" href="#7116" class="Bound">Γ</a><a name="7237"> </a><a name="7238" href="#3817" class="InductiveConstructor">nat</a><a name="7241"> </a><a name="7242" class="Symbol">→</a><a name="7243"> </a><a name="7244" href="#7106" class="Datatype">Term</a><a name="7248"> </a><a name="7249" href="#7116" class="Bound">Γ</a><a name="7250"> </a><a name="7251" href="#3817" class="InductiveConstructor">nat</a><a name="7254"> </a><a name="7255" class="Symbol">→</a><a name="7256"> </a><a name="7257" href="#7106" class="Datatype">Term</a><a name="7261"> </a><a name="7262" href="#7116" class="Bound">Γ</a><a name="7263"> </a><a name="7264" href="#3817" class="InductiveConstructor">nat</a><a name="7267">
  </a><a name="7270" href="#7270" class="InductiveConstructor Operator">_·_</a><a name="7273"> </a><a name="7274" class="Symbol">:</a><a name="7275"> </a><a name="7276" class="Symbol">∀</a><a name="7277"> </a><a name="7278" class="Symbol">{</a><a name="7279" href="#7279" class="Bound">σ</a><a name="7280"> </a><a name="7281" href="#7281" class="Bound">τ</a><a name="7282" class="Symbol">}</a><a name="7283"> </a><a name="7284" class="Symbol">→</a><a name="7285"> </a><a name="7286" href="#7106" class="Datatype">Term</a><a name="7290"> </a><a name="7291" href="#7116" class="Bound">Γ</a><a name="7292"> </a><a name="7293" class="Symbol">(</a><a name="7294" href="#7279" class="Bound">σ</a><a name="7295"> </a><a name="7296" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="7297"> </a><a name="7298" href="#7281" class="Bound">τ</a><a name="7299" class="Symbol">)</a><a name="7300"> </a><a name="7301" class="Symbol">→</a><a name="7302"> </a><a name="7303" href="#7106" class="Datatype">Term</a><a name="7307"> </a><a name="7308" href="#7116" class="Bound">Γ</a><a name="7309"> </a><a name="7310" href="#7279" class="Bound">σ</a><a name="7311"> </a><a name="7312" class="Symbol">→</a><a name="7313"> </a><a name="7314" href="#7106" class="Datatype">Term</a><a name="7318"> </a><a name="7319" href="#7116" class="Bound">Γ</a><a name="7320"> </a><a name="7321" href="#7281" class="Bound">τ</a><a name="7322">
  </a><a name="7325" href="#7325" class="InductiveConstructor">lam</a><a name="7328"> </a><a name="7329" class="Symbol">:</a><a name="7330"> </a><a name="7331" class="Symbol">∀</a><a name="7332"> </a><a name="7333" href="#7333" class="Bound">σ</a><a name="7334"> </a><a name="7335" class="Symbol">{</a><a name="7336" href="#7336" class="Bound">τ</a><a name="7337" class="Symbol">}</a><a name="7338"> </a><a name="7339" class="Symbol">→</a><a name="7340"> </a><a name="7341" href="#7106" class="Datatype">Term</a><a name="7345"> </a><a name="7346" class="Symbol">(</a><a name="7347" href="#7333" class="Bound">σ</a><a name="7348"> </a><a name="7349" class="InductiveConstructor Operator">∷</a><a name="7350"> </a><a name="7351" href="#7116" class="Bound">Γ</a><a name="7352" class="Symbol">)</a><a name="7353"> </a><a name="7354" href="#7336" class="Bound">τ</a><a name="7355"> </a><a name="7356" class="Symbol">→</a><a name="7357"> </a><a name="7358" href="#7106" class="Datatype">Term</a><a name="7362"> </a><a name="7363" href="#7116" class="Bound">Γ</a><a name="7364"> </a><a name="7365" class="Symbol">(</a><a name="7366" href="#7333" class="Bound">σ</a><a name="7367"> </a><a name="7368" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="7369"> </a><a name="7370" href="#7336" class="Bound">τ</a><a name="7371" class="Symbol">)</a><a name="7372">
</a></code></pre>
<p>Note that in the <code>var</code> case we could have written</p>
<pre><code>var : (v : Fin n) → Term Γ (lookup v Γ)</code></pre>
<p>However this would have caused problems further down the line,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and thus we quantify over a type <code>τ</code> and use an explicit equality.</p>
<p>Also in <code>var</code>, we use <code>Fin</code> to make sure that the index is indeed “in scope”. If the context is of length <code>n</code>, an index of type <code>Fin n</code> makes sure that we can look up the type of the variable, since <code>Fin n</code> represents the type of all naturals less than <code>n</code>:</p>
<pre><code>lookup : ∀ {n} {A : Set} → Fin n → Vec A n → A</code></pre>
<p>Closed terms will be those living in empty contexts:</p>
<pre class="Agda"><code><a name="8068" class="Markup"></a><a name="8080">
</a><a name="8081" href="#8081" class="Function">Closed</a><a name="8087"> </a><a name="8088" class="Symbol">:</a><a name="8089"> </a><a name="8090" href="#3798" class="Datatype">Type</a><a name="8094"> </a><a name="8095" class="Symbol">→</a><a name="8096"> </a><a name="8097" class="PrimitiveType">Set</a><a name="8100">
</a><a name="8101" href="#8081" class="Function">Closed</a><a name="8107"> </a><a name="8108" class="Symbol">=</a><a name="8109"> </a><a name="8110" href="#7106" class="Datatype">Term</a><a name="8114"> </a><a name="8115" class="InductiveConstructor">[]</a><a name="8117">
</a></code></pre>
<p>For example, we can write a function doubling numbers in <code>Term</code>. The type will predictably be <code>nat ⇒ nat</code>:</p>
<pre class="Agda"><code><a name="8239" class="Markup"></a><a name="8251">
</a><a name="8252" href="#8252" class="Function">double</a><a name="8258"> </a><a name="8259" class="Symbol">:</a><a name="8260"> </a><a name="8261" href="#8081" class="Function">Closed</a><a name="8267"> </a><a name="8268" class="Symbol">(</a><a name="8269" href="#3817" class="InductiveConstructor">nat</a><a name="8272"> </a><a name="8273" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="8274"> </a><a name="8275" href="#3817" class="InductiveConstructor">nat</a><a name="8278" class="Symbol">)</a><a name="8279">
</a><a name="8280" href="#8252" class="Function">double</a><a name="8286"> </a><a name="8287" class="Symbol">=</a><a name="8288"> </a><a name="8289" href="#7325" class="InductiveConstructor">lam</a><a name="8292"> </a><a name="8293" href="#3817" class="InductiveConstructor">nat</a><a name="8296"> </a><a name="8297" class="Symbol">(</a><a name="8298" href="#7148" class="InductiveConstructor">var</a><a name="8301"> </a><a name="8302" class="InductiveConstructor">zero</a><a name="8306"> </a><a name="8307" class="InductiveConstructor">refl</a><a name="8311"> </a><a name="8312" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="8313"> </a><a name="8314" href="#7148" class="InductiveConstructor">var</a><a name="8317"> </a><a name="8318" class="InductiveConstructor">zero</a><a name="8322"> </a><a name="8323" class="InductiveConstructor">refl</a><a name="8327" class="Symbol">)</a><a name="8328">
</a></code></pre>
<p>We can also write a function that forgets the type information and gets us <code>Syntax</code> from <code>Term</code>:</p>
<pre class="Agda"><code><a name="8439" class="Markup"></a><a name="8451">
</a><a name="8452" href="#8452" class="Function">erase</a><a name="8457"> </a><a name="8458" class="Symbol">:</a><a name="8459"> </a><a name="8460" class="Symbol">∀</a><a name="8461"> </a><a name="8462" class="Symbol">{</a><a name="8463" href="#8463" class="Bound">n</a><a name="8464" class="Symbol">}</a><a name="8465"> </a><a name="8466" class="Symbol">{</a><a name="8467" href="#8467" class="Bound">Γ</a><a name="8468"> </a><a name="8469" class="Symbol">:</a><a name="8470"> </a><a name="8471" href="#6804" class="Function">Ctx</a><a name="8474"> </a><a name="8475" href="#8463" class="Bound">n</a><a name="8476" class="Symbol">}</a><a name="8477"> </a><a name="8478" class="Symbol">{</a><a name="8479" href="#8479" class="Bound">τ</a><a name="8480" class="Symbol">}</a><a name="8481"> </a><a name="8482" class="Symbol">→</a><a name="8483"> </a><a name="8484" href="#7106" class="Datatype">Term</a><a name="8488"> </a><a name="8489" href="#8467" class="Bound">Γ</a><a name="8490"> </a><a name="8491" href="#8479" class="Bound">τ</a><a name="8492"> </a><a name="8493" class="Symbol">→</a><a name="8494"> </a><a name="8495" href="#4701" class="Datatype">Syntax</a><a name="8501">
</a><a name="8502" href="#8452" class="Function">erase</a><a name="8507"> </a><a name="8508" class="Symbol">(</a><a name="8509" href="#7148" class="InductiveConstructor">var</a><a name="8512"> </a><a name="8513" href="#8513" class="Bound">v</a><a name="8514"> </a><a name="8515" class="Symbol">_)</a><a name="8517"> </a><a name="8518" class="Symbol">=</a><a name="8519"> </a><a name="8520" href="#4770" class="InductiveConstructor">var</a><a name="8523"> </a><a name="8524" class="Symbol">(</a><a name="8525" class="Function">toℕ</a><a name="8528"> </a><a name="8529" href="#8513" class="Bound">v</a><a name="8530" class="Symbol">)</a><a name="8531">
</a><a name="8532" href="#8452" class="Function">erase</a><a name="8537"> </a><a name="8538" class="Symbol">(</a><a name="8539" href="#7202" class="InductiveConstructor">lit</a><a name="8542"> </a><a name="8543" href="#8543" class="Bound">n</a><a name="8544" class="Symbol">)</a><a name="8545">   </a><a name="8548" class="Symbol">=</a><a name="8549"> </a><a name="8550" href="#4812" class="InductiveConstructor">lit</a><a name="8553"> </a><a name="8554" href="#8543" class="Bound">n</a><a name="8555">
</a><a name="8556" href="#8452" class="Function">erase</a><a name="8561"> </a><a name="8562" class="Symbol">(</a><a name="8563" href="#8563" class="Bound">t</a><a name="8564"> </a><a name="8565" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="8566"> </a><a name="8567" href="#8567" class="Bound">u</a><a name="8568" class="Symbol">)</a><a name="8569">   </a><a name="8572" class="Symbol">=</a><a name="8573"> </a><a name="8574" href="#8452" class="Function">erase</a><a name="8579"> </a><a name="8580" href="#8563" class="Bound">t</a><a name="8581"> </a><a name="8582" href="#4846" class="InductiveConstructor Operator">⊕</a><a name="8583"> </a><a name="8584" href="#8452" class="Function">erase</a><a name="8589"> </a><a name="8590" href="#8567" class="Bound">u</a><a name="8591">
</a><a name="8592" href="#8452" class="Function">erase</a><a name="8597"> </a><a name="8598" class="Symbol">(</a><a name="8599" href="#8599" class="Bound">t</a><a name="8600"> </a><a name="8601" href="#7270" class="InductiveConstructor Operator">·</a><a name="8602"> </a><a name="8603" href="#8603" class="Bound">u</a><a name="8604" class="Symbol">)</a><a name="8605">   </a><a name="8608" class="Symbol">=</a><a name="8609"> </a><a name="8610" href="#8452" class="Function">erase</a><a name="8615"> </a><a name="8616" href="#8599" class="Bound">t</a><a name="8617"> </a><a name="8618" href="#4906" class="InductiveConstructor Operator">·</a><a name="8619"> </a><a name="8620" href="#8452" class="Function">erase</a><a name="8625"> </a><a name="8626" href="#8603" class="Bound">u</a><a name="8627">
</a><a name="8628" href="#8452" class="Function">erase</a><a name="8633"> </a><a name="8634" class="Symbol">(</a><a name="8635" href="#7325" class="InductiveConstructor">lam</a><a name="8638"> </a><a name="8639" href="#8639" class="Bound">σ</a><a name="8640"> </a><a name="8641" href="#8641" class="Bound">t</a><a name="8642" class="Symbol">)</a><a name="8643"> </a><a name="8644" class="Symbol">=</a><a name="8645"> </a><a name="8646" href="#5038" class="InductiveConstructor">lam</a><a name="8649"> </a><a name="8650" href="#8639" class="Bound">σ</a><a name="8651"> </a><a name="8652" class="Symbol">(</a><a name="8653" href="#8452" class="Function">erase</a><a name="8658"> </a><a name="8659" href="#8641" class="Bound">t</a><a name="8660" class="Symbol">)</a><a name="8661">
</a></code></pre>
<h3 id="type-equality">Type equality <a href="#type-equality" class="section-link">#</a></h3>
<p>Before writing our type checking function, we need some additional tools. We will begin by defining a decision procedure for equality between types. First two lemmas telling us that if two arrow types are equal, both sides of the arrows are equal too:</p>
<pre class="Agda"><code><a name="8948" class="Markup"></a><a name="8960">
</a><a name="8961" href="#8961" class="Function">≡⇒₁</a><a name="8964"> </a><a name="8965" class="Symbol">:</a><a name="8966"> </a><a name="8967" class="Symbol">∀</a><a name="8968"> </a><a name="8969" class="Symbol">{</a><a name="8970" href="#8970" class="Bound">σ</a><a name="8971"> </a><a name="8972" href="#8972" class="Bound">σ′</a><a name="8974"> </a><a name="8975" href="#8975" class="Bound">τ</a><a name="8976"> </a><a name="8977" href="#8977" class="Bound">τ′</a><a name="8979" class="Symbol">}</a><a name="8980"> </a><a name="8981" class="Symbol">→</a><a name="8982"> </a><a name="8983" href="#8970" class="Bound">σ</a><a name="8984"> </a><a name="8985" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="8986"> </a><a name="8987" href="#8975" class="Bound">τ</a><a name="8988"> </a><a name="8989" class="Datatype Operator">≡</a><a name="8990"> </a><a name="8991" href="#8972" class="Bound">σ′</a><a name="8993"> </a><a name="8994" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="8995"> </a><a name="8996" href="#8977" class="Bound">τ′</a><a name="8998"> </a><a name="8999" class="Symbol">→</a><a name="9000"> </a><a name="9001" href="#8970" class="Bound">σ</a><a name="9002"> </a><a name="9003" class="Datatype Operator">≡</a><a name="9004"> </a><a name="9005" href="#8972" class="Bound">σ′</a><a name="9007">
</a><a name="9008" href="#8961" class="Function">≡⇒₁</a><a name="9011"> </a><a name="9012" class="InductiveConstructor">refl</a><a name="9016"> </a><a name="9017" class="Symbol">=</a><a name="9018"> </a><a name="9019" class="InductiveConstructor">refl</a><a name="9023">
</a><a name="9024" href="#9024" class="Function">≡⇒₂</a><a name="9027"> </a><a name="9028" class="Symbol">:</a><a name="9029"> </a><a name="9030" class="Symbol">∀</a><a name="9031"> </a><a name="9032" class="Symbol">{</a><a name="9033" href="#9033" class="Bound">σ</a><a name="9034"> </a><a name="9035" href="#9035" class="Bound">σ′</a><a name="9037"> </a><a name="9038" href="#9038" class="Bound">τ</a><a name="9039"> </a><a name="9040" href="#9040" class="Bound">τ′</a><a name="9042" class="Symbol">}</a><a name="9043"> </a><a name="9044" class="Symbol">→</a><a name="9045"> </a><a name="9046" href="#9033" class="Bound">σ</a><a name="9047"> </a><a name="9048" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9049"> </a><a name="9050" href="#9038" class="Bound">τ</a><a name="9051"> </a><a name="9052" class="Datatype Operator">≡</a><a name="9053"> </a><a name="9054" href="#9035" class="Bound">σ′</a><a name="9056"> </a><a name="9057" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9058"> </a><a name="9059" href="#9040" class="Bound">τ′</a><a name="9061"> </a><a name="9062" class="Symbol">→</a><a name="9063"> </a><a name="9064" href="#9038" class="Bound">τ</a><a name="9065"> </a><a name="9066" class="Datatype Operator">≡</a><a name="9067"> </a><a name="9068" href="#9040" class="Bound">τ′</a><a name="9070">
</a><a name="9071" href="#9024" class="Function">≡⇒₂</a><a name="9074"> </a><a name="9075" class="InductiveConstructor">refl</a><a name="9079"> </a><a name="9080" class="Symbol">=</a><a name="9081"> </a><a name="9082" class="InductiveConstructor">refl</a><a name="9086">
</a></code></pre>
<p>Then the actual function. <code>Dec</code> is inhabited by either evidence that the relation holds, using the constructor <code>yes</code>; or that it doesn’t, using <code>no</code>:</p>
<pre class="Agda"><code><a name="9251" class="Markup"></a><a name="9263">
</a><a name="9264" href="#9264" class="Function Operator">_≟_</a><a name="9267"> </a><a name="9268" class="Symbol">:</a><a name="9269"> </a><a name="9270" class="Symbol">(</a><a name="9271" href="#9271" class="Bound">τ</a><a name="9272"> </a><a name="9273" href="#9273" class="Bound">σ</a><a name="9274"> </a><a name="9275" class="Symbol">:</a><a name="9276"> </a><a name="9277" href="#3798" class="Datatype">Type</a><a name="9281" class="Symbol">)</a><a name="9282"> </a><a name="9283" class="Symbol">→</a><a name="9284"> </a><a name="9285" class="Datatype">Dec</a><a name="9288"> </a><a name="9289" class="Symbol">(</a><a name="9290" href="#9271" class="Bound">τ</a><a name="9291"> </a><a name="9292" class="Datatype Operator">≡</a><a name="9293"> </a><a name="9294" href="#9273" class="Bound">σ</a><a name="9295" class="Symbol">)</a><a name="9296">
</a><a name="9297" href="#3817" class="InductiveConstructor">nat</a><a name="9300">   </a><a name="9303" href="#9264" class="Function Operator">≟</a><a name="9304"> </a><a name="9305" href="#3817" class="InductiveConstructor">nat</a><a name="9308">   </a><a name="9311" class="Symbol">=</a><a name="9312"> </a><a name="9313" class="InductiveConstructor">yes</a><a name="9316"> </a><a name="9317" class="InductiveConstructor">refl</a><a name="9321">
</a><a name="9322" href="#3817" class="InductiveConstructor">nat</a><a name="9325">   </a><a name="9328" href="#9264" class="Function Operator">≟</a><a name="9329"> </a><a name="9330" class="Symbol">_</a><a name="9331"> </a><a name="9332" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9333"> </a><a name="9334" class="Symbol">_</a><a name="9335"> </a><a name="9336" class="Symbol">=</a><a name="9337"> </a><a name="9338" class="InductiveConstructor">no</a><a name="9340"> </a><a name="9341" class="Symbol">λ()</a><a name="9344">
</a><a name="9345" class="Symbol">_</a><a name="9346"> </a><a name="9347" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9348"> </a><a name="9349" class="Symbol">_</a><a name="9350"> </a><a name="9351" href="#9264" class="Function Operator">≟</a><a name="9352"> </a><a name="9353" href="#3817" class="InductiveConstructor">nat</a><a name="9356">   </a><a name="9359" class="Symbol">=</a><a name="9360"> </a><a name="9361" class="InductiveConstructor">no</a><a name="9363"> </a><a name="9364" class="Symbol">λ()</a><a name="9367">
</a><a name="9368" href="#9368" class="Bound">σ</a><a name="9369"> </a><a name="9370" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9371"> </a><a name="9372" href="#9372" class="Bound">τ</a><a name="9373"> </a><a name="9374" href="#9264" class="Function Operator">≟</a><a name="9375"> </a><a name="9376" href="#9376" class="Bound">σ′</a><a name="9378"> </a><a name="9379" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9380"> </a><a name="9381" href="#9381" class="Bound">τ′</a><a name="9383"> </a><a name="9384" class="Keyword">with</a><a name="9388"> </a><a name="9389" href="#9368" class="Bound">σ</a><a name="9390"> </a><a name="9391" href="#9264" class="Function Operator">≟</a><a name="9392"> </a><a name="9393" href="#9376" class="Bound">σ′</a><a name="9395"> </a><a name="9396" class="Symbol">|</a><a name="9397"> </a><a name="9398" href="#9372" class="Bound">τ</a><a name="9399"> </a><a name="9400" href="#9264" class="Function Operator">≟</a><a name="9401"> </a><a name="9402" href="#9381" class="Bound">τ′</a><a name="9404">
</a><a name="9405" href="#9405" class="Bound">σ</a><a name="9406"> </a><a name="9407" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9408"> </a><a name="9409" href="#9409" class="Bound">τ</a><a name="9410"> </a><a name="9411" href="#9264" class="Function Operator">≟</a><a name="9412"> </a><a name="9413" class="DottedPattern Symbol">.</a><a name="9414" href="#9405" class="DottedPattern Bound">σ</a><a name="9415"> </a><a name="9416" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9417"> </a><a name="9418" class="DottedPattern Symbol">.</a><a name="9419" href="#9409" class="DottedPattern Bound">τ</a><a name="9420"> </a><a name="9421" class="Symbol">|</a><a name="9422"> </a><a name="9423" class="InductiveConstructor">yes</a><a name="9426"> </a><a name="9427" class="InductiveConstructor">refl</a><a name="9431"> </a><a name="9432" class="Symbol">|</a><a name="9433"> </a><a name="9434" class="InductiveConstructor">yes</a><a name="9437"> </a><a name="9438" class="InductiveConstructor">refl</a><a name="9442"> </a><a name="9443" class="Symbol">=</a><a name="9444"> </a><a name="9445" class="InductiveConstructor">yes</a><a name="9448"> </a><a name="9449" class="InductiveConstructor">refl</a><a name="9453">
</a><a name="9454" href="#9454" class="Bound">σ</a><a name="9455"> </a><a name="9456" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9457"> </a><a name="9458" href="#9458" class="Bound">τ</a><a name="9459"> </a><a name="9460" href="#9264" class="Function Operator">≟</a><a name="9461"> </a><a name="9462" href="#9462" class="Bound">σ′</a><a name="9464"> </a><a name="9465" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="9466"> </a><a name="9467" href="#9467" class="Bound">τ′</a><a name="9469"> </a><a name="9470" class="Symbol">|</a><a name="9471"> </a><a name="9472" class="InductiveConstructor">no</a><a name="9474">  </a><a name="9476" href="#9476" class="Bound">σ≢σ′</a><a name="9480"> </a><a name="9481" class="Symbol">|</a><a name="9482"> </a><a name="9483" class="Symbol">_</a><a name="9484">        </a><a name="9492" class="Symbol">=</a><a name="9493"> </a><a name="9494" class="InductiveConstructor">no</a><a name="9496"> </a><a name="9497" class="Symbol">(</a><a name="9498" href="#9476" class="Bound">σ≢σ′</a><a name="9502"> </a><a name="9503" class="Function Operator">∘</a><a name="9504"> </a><a name="9505" href="#8961" class="Function">≡⇒₁</a><a name="9508" class="Symbol">)</a><a name="9509">
</a><a name="9510" href="#9510" class="CatchallClause Bound">σ</a><a name="9511" class="CatchallClause"> </a><a name="9512" href="#3830" class="CatchallClause InductiveConstructor Operator">⇒</a><a name="9513" class="CatchallClause"> </a><a name="9514" href="#9514" class="CatchallClause Bound">τ</a><a name="9515" class="CatchallClause"> </a><a name="9516" href="#9264" class="CatchallClause Function Operator">≟</a><a name="9517" class="CatchallClause"> </a><a name="9518" href="#9518" class="CatchallClause Bound">σ′</a><a name="9520" class="CatchallClause"> </a><a name="9521" href="#3830" class="CatchallClause InductiveConstructor Operator">⇒</a><a name="9522" class="CatchallClause"> </a><a name="9523" href="#9523" class="CatchallClause Bound">τ′</a><a name="9525" class="CatchallClause"> </a><a name="9526" class="CatchallClause Symbol">|</a><a name="9527" class="CatchallClause"> </a><a name="9528" class="CatchallClause Symbol">_</a><a name="9529" class="CatchallClause">        </a><a name="9537" class="CatchallClause Symbol">|</a><a name="9538" class="CatchallClause"> </a><a name="9539" class="CatchallClause InductiveConstructor">no</a><a name="9541" class="CatchallClause"> </a><a name="9542" href="#9542" class="CatchallClause Bound">τ≢τ′</a><a name="9546">  </a><a name="9548" class="Symbol">=</a><a name="9549"> </a><a name="9550" class="InductiveConstructor">no</a><a name="9552"> </a><a name="9553" class="Symbol">(</a><a name="9554" href="#9542" class="Bound">τ≢τ′</a><a name="9558"> </a><a name="9559" class="Function Operator">∘</a><a name="9560"> </a><a name="9561" href="#9024" class="Function">≡⇒₂</a><a name="9564" class="Symbol">)</a><a name="9565">
</a></code></pre>
<p>Note that in the cases where different constructors are present we use <code>λ()</code>, which is a shorthand for a function with an empty pattern—meaning that its input cannot be inhabited. For example when faced with <code>nat ≟ σ ⇒ τ</code> to prove the inequality we need to show that <code>¬ (nat ≡ σ ⇒ τ)</code>, which is a shorthand for <code>(nat ≡ σ ⇒ τ) → ⊥</code>—“We can derive falsity given that <code>nat</code> is equal to an arrow type.” But given how <code>≡</code> is defined Agda knows that its indices must be the same, and thus that <code>nat ≡ σ ⇒ τ</code> cannot be inhabited, allowing us to use an empty pattern.</p>
<p>Moreover, note how we use dependent pattern matching when recursing down the structure of the types: when pattern matching on an equality proof in a <code>yes</code> using <code>refl</code> the two relevant types are constrained to be the same using dotted patterns, which allows us to use <code>refl</code> again to prove equality of the type as a whole.</p>
<h3 id="from-fin-to-ℕ">From <code>Fin</code> to <code>ℕ</code> <a href="#from-fin-to-ℕ" class="section-link">#</a></h3>
<p>The second tool that we will use is a “view” to tell us whether a given <code>ℕ</code> “fits” in a <code>Fin n</code>.</p>
<pre class="Agda"><code><a name="10590" class="Markup"></a><a name="10602">
</a><a name="10603" class="Keyword">data</a><a name="10607"> </a><a name="10608" href="#10608" class="Datatype">Fromℕ</a><a name="10613"> </a><a name="10614" class="Symbol">(</a><a name="10615" href="#10615" class="Bound">n</a><a name="10616"> </a><a name="10617" class="Symbol">:</a><a name="10618"> </a><a name="10619" class="Datatype">ℕ</a><a name="10620" class="Symbol">)</a><a name="10621"> </a><a name="10622" class="Symbol">:</a><a name="10623"> </a><a name="10624" class="Datatype">ℕ</a><a name="10625"> </a><a name="10626" class="Symbol">→</a><a name="10627"> </a><a name="10628" class="PrimitiveType">Set</a><a name="10631"> </a><a name="10632" class="Keyword">where</a><a name="10637">
  </a><a name="10640" href="#10640" class="InductiveConstructor">yes</a><a name="10643"> </a><a name="10644" class="Symbol">:</a><a name="10645"> </a><a name="10646" class="Symbol">(</a><a name="10647" href="#10647" class="Bound">m</a><a name="10648"> </a><a name="10649" class="Symbol">:</a><a name="10650"> </a><a name="10651" class="Datatype">Fin</a><a name="10654"> </a><a name="10655" href="#10615" class="Bound">n</a><a name="10656" class="Symbol">)</a><a name="10657"> </a><a name="10658" class="Symbol">→</a><a name="10659"> </a><a name="10660" href="#10608" class="Datatype">Fromℕ</a><a name="10665"> </a><a name="10666" href="#10615" class="Bound">n</a><a name="10667"> </a><a name="10668" class="Symbol">(</a><a name="10669" class="Function">toℕ</a><a name="10672"> </a><a name="10673" href="#10647" class="Bound">m</a><a name="10674" class="Symbol">)</a><a name="10675">
  </a><a name="10678" href="#10678" class="InductiveConstructor">no</a><a name="10680">  </a><a name="10682" class="Symbol">:</a><a name="10683"> </a><a name="10684" class="Symbol">(</a><a name="10685" href="#10685" class="Bound">m</a><a name="10686"> </a><a name="10687" class="Symbol">:</a><a name="10688"> </a><a name="10689" class="Datatype">ℕ</a><a name="10690" class="Symbol">)</a><a name="10691">     </a><a name="10696" class="Symbol">→</a><a name="10697"> </a><a name="10698" href="#10608" class="Datatype">Fromℕ</a><a name="10703"> </a><a name="10704" href="#10615" class="Bound">n</a><a name="10705"> </a><a name="10706" class="Symbol">(</a><a name="10707" href="#10615" class="Bound">n</a><a name="10708"> </a><a name="10709" class="Primitive Operator">+</a><a name="10710"> </a><a name="10711" href="#10685" class="Bound">m</a><a name="10712" class="Symbol">)</a><a name="10713">
</a></code></pre>
<p><code>Fromℕ</code> is parametrised over the “upper bound” <code>n</code>, and indexed over the <code>ℕ</code> that we are bringing into <code>Fin n</code>. We can then write a function that tries to convert a number <code>m</code> to a <code>Fin n</code>:</p>
<pre class="Agda"><code><a name="10918" class="Markup"></a><a name="10930">
</a><a name="10931" href="#10931" class="Function">fromℕ</a><a name="10936"> </a><a name="10937" class="Symbol">:</a><a name="10938"> </a><a name="10939" class="Symbol">∀</a><a name="10940"> </a><a name="10941" href="#10941" class="Bound">n</a><a name="10942"> </a><a name="10943" href="#10943" class="Bound">m</a><a name="10944"> </a><a name="10945" class="Symbol">→</a><a name="10946"> </a><a name="10947" href="#10608" class="Datatype">Fromℕ</a><a name="10952"> </a><a name="10953" href="#10941" class="Bound">n</a><a name="10954"> </a><a name="10955" href="#10943" class="Bound">m</a><a name="10956">
</a><a name="10957" href="#10931" class="Function">fromℕ</a><a name="10962"> </a><a name="10963" class="InductiveConstructor">zero</a><a name="10967">    </a><a name="10971" href="#10971" class="Bound">m</a><a name="10972">    </a><a name="10976" class="Symbol">=</a><a name="10977"> </a><a name="10978" href="#10678" class="InductiveConstructor">no</a><a name="10980"> </a><a name="10981" href="#10971" class="Bound">m</a><a name="10982">
</a><a name="10983" href="#10931" class="Function">fromℕ</a><a name="10988"> </a><a name="10989" class="Symbol">(</a><a name="10990" class="InductiveConstructor">suc</a><a name="10993"> </a><a name="10994" href="#10994" class="Bound">n</a><a name="10995" class="Symbol">)</a><a name="10996"> </a><a name="10997" class="InductiveConstructor">zero</a><a name="11001"> </a><a name="11002" class="Symbol">=</a><a name="11003"> </a><a name="11004" href="#10640" class="InductiveConstructor">yes</a><a name="11007"> </a><a name="11008" class="InductiveConstructor">zero</a><a name="11012">
</a><a name="11013" href="#10931" class="Function">fromℕ</a><a name="11018"> </a><a name="11019" class="Symbol">(</a><a name="11020" class="InductiveConstructor">suc</a><a name="11023"> </a><a name="11024" href="#11024" class="Bound">n</a><a name="11025" class="Symbol">)</a><a name="11026"> </a><a name="11027" class="Symbol">(</a><a name="11028" class="InductiveConstructor">suc</a><a name="11031"> </a><a name="11032" href="#11032" class="Bound">m</a><a name="11033" class="Symbol">)</a><a name="11034"> </a><a name="11035" class="Keyword">with</a><a name="11039"> </a><a name="11040" href="#10931" class="Function">fromℕ</a><a name="11045"> </a><a name="11046" href="#11024" class="Bound">n</a><a name="11047"> </a><a name="11048" href="#11032" class="Bound">m</a><a name="11049">
</a><a name="11050" href="#10931" class="Function">fromℕ</a><a name="11055"> </a><a name="11056" class="Symbol">(</a><a name="11057" class="InductiveConstructor">suc</a><a name="11060"> </a><a name="11061" href="#11061" class="Bound">n</a><a name="11062" class="Symbol">)</a><a name="11063"> </a><a name="11064" class="Symbol">(</a><a name="11065" class="InductiveConstructor">suc</a><a name="11068"> </a><a name="11069" class="DottedPattern Symbol">.(</a><a name="11071" class="DottedPattern Function">toℕ</a><a name="11074"> </a><a name="11075" href="#11085" class="DottedPattern Bound">m</a><a name="11076" class="DottedPattern Symbol">)</a><a name="11077" class="Symbol">)</a><a name="11078"> </a><a name="11079" class="Symbol">|</a><a name="11080"> </a><a name="11081" href="#10640" class="InductiveConstructor">yes</a><a name="11084"> </a><a name="11085" href="#11085" class="Bound">m</a><a name="11086"> </a><a name="11087" class="Symbol">=</a><a name="11088"> </a><a name="11089" href="#10640" class="InductiveConstructor">yes</a><a name="11092"> </a><a name="11093" class="Symbol">(</a><a name="11094" class="InductiveConstructor">suc</a><a name="11097"> </a><a name="11098" href="#11085" class="Bound">m</a><a name="11099" class="Symbol">)</a><a name="11100">
</a><a name="11101" href="#10931" class="Function">fromℕ</a><a name="11106"> </a><a name="11107" class="Symbol">(</a><a name="11108" class="InductiveConstructor">suc</a><a name="11111"> </a><a name="11112" href="#11112" class="Bound">n</a><a name="11113" class="Symbol">)</a><a name="11114"> </a><a name="11115" class="Symbol">(</a><a name="11116" class="InductiveConstructor">suc</a><a name="11119"> </a><a name="11120" class="DottedPattern Symbol">.(</a><a name="11122" href="#11112" class="DottedPattern Bound">n</a><a name="11123"> </a><a name="11124" class="DottedPattern Primitive Operator">+</a><a name="11125"> </a><a name="11126" href="#11136" class="DottedPattern Bound">m</a><a name="11127" class="DottedPattern Symbol">)</a><a name="11128" class="Symbol">)</a><a name="11129"> </a><a name="11130" class="Symbol">|</a><a name="11131"> </a><a name="11132" href="#10678" class="InductiveConstructor">no</a><a name="11134">  </a><a name="11136" href="#11136" class="Bound">m</a><a name="11137"> </a><a name="11138" class="Symbol">=</a><a name="11139"> </a><a name="11140" href="#10678" class="InductiveConstructor">no</a><a name="11142"> </a><a name="11143" href="#11136" class="Bound">m</a><a name="11144">
</a></code></pre>
<h3 id="type-checking">Type checking <a href="#type-checking" class="section-link">#</a></h3>
<p>Finally we can proceed to the actual type checking procedure. As with <code>Fromℕ</code>, we define a data type indexed over what will be the input of our function—some piece of untyped <code>Syntax</code>:</p>
<pre class="Agda"><code><a name="11365" class="Markup"></a><a name="11377">
</a><a name="11378" class="Keyword">data</a><a name="11382"> </a><a name="11383" href="#11383" class="Datatype">Check</a><a name="11388"> </a><a name="11389" class="Symbol">{</a><a name="11390" href="#11390" class="Bound">n</a><a name="11391" class="Symbol">}</a><a name="11392"> </a><a name="11393" class="Symbol">(</a><a name="11394" href="#11394" class="Bound">Γ</a><a name="11395"> </a><a name="11396" class="Symbol">:</a><a name="11397"> </a><a name="11398" href="#6804" class="Function">Ctx</a><a name="11401"> </a><a name="11402" href="#11390" class="Bound">n</a><a name="11403" class="Symbol">)</a><a name="11404"> </a><a name="11405" class="Symbol">:</a><a name="11406"> </a><a name="11407" href="#4701" class="Datatype">Syntax</a><a name="11413"> </a><a name="11414" class="Symbol">→</a><a name="11415"> </a><a name="11416" class="PrimitiveType">Set</a><a name="11419"> </a><a name="11420" class="Keyword">where</a><a name="11425">
  </a><a name="11428" href="#11428" class="InductiveConstructor">yes</a><a name="11431"> </a><a name="11432" class="Symbol">:</a><a name="11433"> </a><a name="11434" class="Symbol">(</a><a name="11435" href="#11435" class="Bound">τ</a><a name="11436"> </a><a name="11437" class="Symbol">:</a><a name="11438"> </a><a name="11439" href="#3798" class="Datatype">Type</a><a name="11443" class="Symbol">)</a><a name="11444"> </a><a name="11445" class="Symbol">(</a><a name="11446" href="#11446" class="Bound">t</a><a name="11447"> </a><a name="11448" class="Symbol">:</a><a name="11449"> </a><a name="11450" href="#7106" class="Datatype">Term</a><a name="11454"> </a><a name="11455" href="#11394" class="Bound">Γ</a><a name="11456"> </a><a name="11457" href="#11435" class="Bound">τ</a><a name="11458" class="Symbol">)</a><a name="11459"> </a><a name="11460" class="Symbol">→</a><a name="11461"> </a><a name="11462" href="#11383" class="Datatype">Check</a><a name="11467"> </a><a name="11468" href="#11394" class="Bound">Γ</a><a name="11469"> </a><a name="11470" class="Symbol">(</a><a name="11471" href="#8452" class="Function">erase</a><a name="11476"> </a><a name="11477" href="#11446" class="Bound">t</a><a name="11478" class="Symbol">)</a><a name="11479">
  </a><a name="11482" href="#11482" class="InductiveConstructor">no</a><a name="11484">  </a><a name="11486" class="Symbol">:</a><a name="11487"> </a><a name="11488" class="Symbol">{</a><a name="11489" href="#11489" class="Bound">e</a><a name="11490"> </a><a name="11491" class="Symbol">:</a><a name="11492"> </a><a name="11493" href="#4701" class="Datatype">Syntax</a><a name="11499" class="Symbol">}</a><a name="11500"> </a><a name="11501" class="Symbol">→</a><a name="11502"> </a><a name="11503" href="#11383" class="Datatype">Check</a><a name="11508"> </a><a name="11509" href="#11394" class="Bound">Γ</a><a name="11510"> </a><a name="11511" href="#11489" class="Bound">e</a><a name="11512">
</a></code></pre>
<p><code>Check</code> is parametrised over contexts. If type checking succeeds, we return a type <code>τ</code> and a term <code>t : τ</code>, the erasure of <code>t</code> being the <code>Syntax</code> we were type checking—the <code>yes</code> constructor. We can fail at any time using the constructor <code>no</code>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Our type checking procedure will work with a context and some <code>Syntax</code>:</p>
<pre class="Agda"><code><a name="12524" class="Markup"></a><a name="12536">
</a><a name="12537" href="#12537" class="Function">check</a><a name="12542"> </a><a name="12543" class="Symbol">:</a><a name="12544"> </a><a name="12545" class="Symbol">∀</a><a name="12546"> </a><a name="12547" class="Symbol">{</a><a name="12548" href="#12548" class="Bound">n</a><a name="12549" class="Symbol">}</a><a name="12550"> </a><a name="12551" class="Symbol">(</a><a name="12552" href="#12552" class="Bound">Γ</a><a name="12553"> </a><a name="12554" class="Symbol">:</a><a name="12555"> </a><a name="12556" href="#6804" class="Function">Ctx</a><a name="12559"> </a><a name="12560" href="#12548" class="Bound">n</a><a name="12561" class="Symbol">)</a><a name="12562"> </a><a name="12563" class="Symbol">(</a><a name="12564" href="#12564" class="Bound">t</a><a name="12565"> </a><a name="12566" class="Symbol">:</a><a name="12567"> </a><a name="12568" href="#4701" class="Datatype">Syntax</a><a name="12574" class="Symbol">)</a><a name="12575"> </a><a name="12576" class="Symbol">→</a><a name="12577"> </a><a name="12578" href="#11383" class="Datatype">Check</a><a name="12583"> </a><a name="12584" href="#12552" class="Bound">Γ</a><a name="12585"> </a><a name="12586" href="#12564" class="Bound">t</a><a name="12587">
</a></code></pre>
<p>With <code>var</code>, we make sure that the index is in scope using <code>fromℕ</code>. If it is, the type is determined by what’s in the context at the right index:</p>
<pre class="Agda"><code><a name="12747" class="Markup"></a><a name="12759">
</a><a name="12760" href="#12537" class="Function">check</a><a name="12765"> </a><a name="12766" class="Symbol">{</a><a name="12767" href="#12767" class="Bound">n</a><a name="12768" class="Symbol">}</a><a name="12769"> </a><a name="12770" href="#12770" class="Bound">Γ</a><a name="12771"> </a><a name="12772" class="Symbol">(</a><a name="12773" href="#4770" class="InductiveConstructor">var</a><a name="12776"> </a><a name="12777" href="#12777" class="Bound">v</a><a name="12778" class="Symbol">)</a><a name="12779"> </a><a name="12780" class="Keyword">with</a><a name="12784"> </a><a name="12785" href="#10931" class="Function">fromℕ</a><a name="12790"> </a><a name="12791" href="#12767" class="Bound">n</a><a name="12792"> </a><a name="12793" href="#12777" class="Bound">v</a><a name="12794">
</a><a name="12795" href="#12537" class="Function">check</a><a name="12800"> </a><a name="12801" class="Symbol">{</a><a name="12802" href="#12802" class="Bound">n</a><a name="12803" class="Symbol">}</a><a name="12804"> </a><a name="12805" href="#12805" class="Bound">Γ</a><a name="12806"> </a><a name="12807" class="Symbol">(</a><a name="12808" class="InductiveConstructor">var</a><a name="12811"> </a><a name="12812" class="DottedPattern Symbol">.(</a><a name="12814" class="DottedPattern Function">toℕ</a><a name="12817"> </a><a name="12818" href="#12828" class="DottedPattern Bound">v</a><a name="12819" class="DottedPattern Symbol">)</a><a name="12820" class="Symbol">)</a><a name="12821"> </a><a name="12822" class="Symbol">|</a><a name="12823"> </a><a name="12824" href="#10640" class="InductiveConstructor">yes</a><a name="12827"> </a><a name="12828" href="#12828" class="Bound">v</a><a name="12829"> </a><a name="12830" class="Symbol">=</a><a name="12831"> </a><a name="12832" href="#11428" class="InductiveConstructor">yes</a><a name="12835"> </a><a name="12836" class="Symbol">(</a><a name="12837" class="Function">lookup</a><a name="12843"> </a><a name="12844" href="#12828" class="Bound">v</a><a name="12845"> </a><a name="12846" href="#12805" class="Bound">Γ</a><a name="12847" class="Symbol">)</a><a name="12848"> </a><a name="12849" class="Symbol">(</a><a name="12850" href="#7148" class="InductiveConstructor">var</a><a name="12853"> </a><a name="12854" href="#12828" class="Bound">v</a><a name="12855"> </a><a name="12856" class="InductiveConstructor">refl</a><a name="12860" class="Symbol">)</a><a name="12861">
</a><a name="12862" href="#12537" class="Function">check</a><a name="12867"> </a><a name="12868" class="Symbol">{</a><a name="12869" href="#12869" class="Bound">n</a><a name="12870" class="Symbol">}</a><a name="12871"> </a><a name="12872" href="#12872" class="Bound">Γ</a><a name="12873"> </a><a name="12874" class="Symbol">(</a><a name="12875" class="InductiveConstructor">var</a><a name="12878"> </a><a name="12879" class="DottedPattern Symbol">.(</a><a name="12881" href="#12869" class="DottedPattern Bound">n</a><a name="12882"> </a><a name="12883" class="DottedPattern Primitive Operator">+</a><a name="12884"> </a><a name="12885" href="#12895" class="DottedPattern Bound">m</a><a name="12886" class="DottedPattern Symbol">)</a><a name="12887" class="Symbol">)</a><a name="12888"> </a><a name="12889" class="Symbol">|</a><a name="12890"> </a><a name="12891" href="#10678" class="InductiveConstructor">no</a><a name="12893">  </a><a name="12895" href="#12895" class="Bound">m</a><a name="12896"> </a><a name="12897" class="Symbol">=</a><a name="12898"> </a><a name="12899" href="#11482" class="InductiveConstructor">no</a><a name="12901">
</a></code></pre>
<p>Literals are of type <code>nat</code>:</p>
<pre class="Agda"><code><a name="12943" class="Markup"></a><a name="12955">
</a><a name="12956" href="#12537" class="Function">check</a><a name="12961"> </a><a name="12962" href="#12962" class="Bound">Γ</a><a name="12963"> </a><a name="12964" class="Symbol">(</a><a name="12965" href="#4812" class="InductiveConstructor">lit</a><a name="12968"> </a><a name="12969" href="#12969" class="Bound">n</a><a name="12970" class="Symbol">)</a><a name="12971"> </a><a name="12972" class="Symbol">=</a><a name="12973"> </a><a name="12974" href="#11428" class="InductiveConstructor">yes</a><a name="12977"> </a><a name="12978" href="#3817" class="InductiveConstructor">nat</a><a name="12981"> </a><a name="12982" class="Symbol">(</a><a name="12983" href="#7202" class="InductiveConstructor">lit</a><a name="12986"> </a><a name="12987" href="#12969" class="Bound">n</a><a name="12988" class="Symbol">)</a><a name="12989">
</a></code></pre>
<p>For additions, we recursively type check the two sides. If they are both <code>nat</code>, the resulting term is <code>nat</code> too. Otherwise, type checking fails:</p>
<pre class="Agda"><code><a name="13150" class="Markup"></a><a name="13162">
</a><a name="13163" href="#12537" class="Function">check</a><a name="13168"> </a><a name="13169" href="#13169" class="Bound">Γ</a><a name="13170"> </a><a name="13171" class="Symbol">(</a><a name="13172" href="#13172" class="Bound">t</a><a name="13173"> </a><a name="13174" href="#4846" class="InductiveConstructor Operator">⊕</a><a name="13175"> </a><a name="13176" href="#13176" class="Bound">u</a><a name="13177" class="Symbol">)</a><a name="13178"> </a><a name="13179" class="Keyword">with</a><a name="13183"> </a><a name="13184" href="#12537" class="Function">check</a><a name="13189"> </a><a name="13190" href="#13169" class="Bound">Γ</a><a name="13191"> </a><a name="13192" href="#13172" class="Bound">t</a><a name="13193"> </a><a name="13194" class="Symbol">|</a><a name="13195"> </a><a name="13196" href="#12537" class="Function">check</a><a name="13201"> </a><a name="13202" href="#13169" class="Bound">Γ</a><a name="13203"> </a><a name="13204" href="#13176" class="Bound">u</a><a name="13205">
</a><a name="13206" href="#12537" class="Function">check</a><a name="13211"> </a><a name="13212" href="#13212" class="Bound">Γ</a><a name="13213"> </a><a name="13214" class="Symbol">(</a><a name="13215" class="DottedPattern Symbol">.(</a><a name="13217" href="#8452" class="DottedPattern Function">erase</a><a name="13222"> </a><a name="13223" href="#13250" class="DottedPattern Bound">t</a><a name="13224" class="DottedPattern Symbol">)</a><a name="13225"> </a><a name="13226" class="InductiveConstructor Operator">⊕</a><a name="13227"> </a><a name="13228" class="DottedPattern Symbol">.(</a><a name="13230" href="#8452" class="DottedPattern Function">erase</a><a name="13235"> </a><a name="13236" href="#13262" class="DottedPattern Bound">u</a><a name="13237" class="DottedPattern Symbol">)</a><a name="13238" class="Symbol">)</a><a name="13239"> </a><a name="13240" class="Symbol">|</a><a name="13241"> </a><a name="13242" href="#11428" class="InductiveConstructor">yes</a><a name="13245"> </a><a name="13246" href="#3817" class="InductiveConstructor">nat</a><a name="13249"> </a><a name="13250" href="#13250" class="Bound">t</a><a name="13251"> </a><a name="13252" class="Symbol">|</a><a name="13253"> </a><a name="13254" href="#11428" class="InductiveConstructor">yes</a><a name="13257"> </a><a name="13258" href="#3817" class="InductiveConstructor">nat</a><a name="13261"> </a><a name="13262" href="#13262" class="Bound">u</a><a name="13263"> </a><a name="13264" class="Symbol">=</a><a name="13265"> </a><a name="13266" href="#11428" class="InductiveConstructor">yes</a><a name="13269"> </a><a name="13270" href="#3817" class="InductiveConstructor">nat</a><a name="13273"> </a><a name="13274" class="Symbol">(</a><a name="13275" href="#13250" class="Bound">t</a><a name="13276"> </a><a name="13277" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="13278"> </a><a name="13279" href="#13262" class="Bound">u</a><a name="13280" class="Symbol">)</a><a name="13281">
</a><a name="13282" href="#12537" class="CatchallClause Function">check</a><a name="13287" class="CatchallClause"> </a><a name="13288" href="#13288" class="CatchallClause Bound">Γ</a><a name="13289" class="CatchallClause"> </a><a name="13290" class="CatchallClause Symbol">(_</a><a name="13292" class="CatchallClause"> </a><a name="13293" class="CatchallClause InductiveConstructor Operator">⊕</a><a name="13294" class="CatchallClause"> </a><a name="13295" class="CatchallClause Symbol">_)</a><a name="13297" class="CatchallClause">                   </a><a name="13316" class="CatchallClause Symbol">|</a><a name="13317" class="CatchallClause"> </a><a name="13318" class="CatchallClause Symbol">_</a><a name="13319" class="CatchallClause">         </a><a name="13328" class="CatchallClause Symbol">|</a><a name="13329" class="CatchallClause"> </a><a name="13330" class="CatchallClause Symbol">_</a><a name="13331">         </a><a name="13340" class="Symbol">=</a><a name="13341"> </a><a name="13342" href="#11482" class="InductiveConstructor">no</a><a name="13344">
</a></code></pre>
<p>Note that when checking against the results of the recursive calls, we use dotted matches to show the relationship between the input <code>Syntax</code> terms and the type checked terms: the former is the erasure of the latter. This way we can invoke <code>yes</code> so that the result will be well typed.</p>
<p>The interactive Agda mode is tremendously useful in these situations. If we are in the situation</p>
<pre><code>check Γ (t ⊕ u) with check Γ t | check Γ u
check Γ (t ⊕ u) | p1 | p2 = {!!}</code></pre>
<p>We can pattern match by placing <code>p1</code> in the hole and then invoking <code>C-c C-c</code>, which will result in</p>
<pre><code>check Γ (.(erase t) ⊕ u) | yes τ t | p2 = {!!}</code></pre>
<p>Agda automatically places the dotted patterns. Then after doing the same for <code>p2</code> and matching <code>nat</code>, we are left with</p>
<pre><code>check Γ (.(erase t) ⊕ .(erase u)) | yes nat t | yes nat u = {!!}</code></pre>
<p>The goal for that hole, as Agda reminds us, is</p>
<pre><code>Check Γ (erase t ⊕ erase u)</code></pre>
<p>We can type <code>yes</code> and then <code>C-r</code> to refine the hole, and then <code>C-a</code> in each hole to tell Agda to try to search for an appropriate term, which in this case succeeds. In general with strong enough types we only write an outline of the function and then a lot of details can be filled in automatically.</p>
<p>For what concerns application, we check that the term we are applying something to has a function type, and that the argument’s type is equal to the domain of said function:</p>
<pre class="Agda"><code><a name="14728" class="Markup"></a><a name="14740">
</a><a name="14741" href="#12537" class="Function">check</a><a name="14746"> </a><a name="14747" href="#14747" class="Bound">Γ</a><a name="14748"> </a><a name="14749" class="Symbol">(</a><a name="14750" href="#14750" class="Bound">t</a><a name="14751"> </a><a name="14752" href="#4906" class="InductiveConstructor Operator">·</a><a name="14753"> </a><a name="14754" href="#14754" class="Bound">u</a><a name="14755" class="Symbol">)</a><a name="14756"> </a><a name="14757" class="Keyword">with</a><a name="14761"> </a><a name="14762" href="#12537" class="Function">check</a><a name="14767"> </a><a name="14768" href="#14747" class="Bound">Γ</a><a name="14769"> </a><a name="14770" href="#14750" class="Bound">t</a><a name="14771"> </a><a name="14772" class="Symbol">|</a><a name="14773"> </a><a name="14774" href="#12537" class="Function">check</a><a name="14779"> </a><a name="14780" href="#14747" class="Bound">Γ</a><a name="14781"> </a><a name="14782" href="#14754" class="Bound">u</a><a name="14783">
</a><a name="14784" href="#12537" class="Function">check</a><a name="14789"> </a><a name="14790" href="#14790" class="Bound">Γ</a><a name="14791"> </a><a name="14792" class="Symbol">(</a><a name="14793" class="DottedPattern Symbol">.(</a><a name="14795" href="#8452" class="DottedPattern Function">erase</a><a name="14800"> </a><a name="14801" href="#14832" class="DottedPattern Bound">t</a><a name="14802" class="DottedPattern Symbol">)</a><a name="14803"> </a><a name="14804" class="InductiveConstructor Operator">·</a><a name="14805"> </a><a name="14806" class="DottedPattern Symbol">.(</a><a name="14808" href="#8452" class="DottedPattern Function">erase</a><a name="14813"> </a><a name="14814" href="#14843" class="DottedPattern Bound">u</a><a name="14815" class="DottedPattern Symbol">)</a><a name="14816" class="Symbol">)</a><a name="14817"> </a><a name="14818" class="Symbol">|</a><a name="14819"> </a><a name="14820" href="#11428" class="InductiveConstructor">yes</a><a name="14823"> </a><a name="14824" class="Symbol">(</a><a name="14825" href="#14825" class="Bound">σ</a><a name="14826"> </a><a name="14827" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="14828"> </a><a name="14829" href="#14829" class="Bound">τ</a><a name="14830" class="Symbol">)</a><a name="14831"> </a><a name="14832" href="#14832" class="Bound">t</a><a name="14833"> </a><a name="14834" class="Symbol">|</a><a name="14835"> </a><a name="14836" href="#11428" class="InductiveConstructor">yes</a><a name="14839"> </a><a name="14840" href="#14840" class="Bound">σ′</a><a name="14842"> </a><a name="14843" href="#14843" class="Bound">u</a><a name="14844"> </a><a name="14845" class="Keyword">with</a><a name="14849"> </a><a name="14850" href="#14825" class="Bound">σ</a><a name="14851"> </a><a name="14852" href="#9264" class="Function Operator">≟</a><a name="14853"> </a><a name="14854" href="#14840" class="Bound">σ′</a><a name="14856">
</a><a name="14857" href="#12537" class="Function">check</a><a name="14862"> </a><a name="14863" href="#14863" class="Bound">Γ</a><a name="14864"> </a><a name="14865" class="Symbol">(</a><a name="14866" class="DottedPattern Symbol">.(</a><a name="14868" href="#8452" class="DottedPattern Function">erase</a><a name="14873"> </a><a name="14874" href="#14905" class="DottedPattern Bound">t</a><a name="14875" class="DottedPattern Symbol">)</a><a name="14876"> </a><a name="14877" class="InductiveConstructor Operator">·</a><a name="14878"> </a><a name="14879" class="DottedPattern Symbol">.(</a><a name="14881" href="#8452" class="DottedPattern Function">erase</a><a name="14886"> </a><a name="14887" href="#14916" class="DottedPattern Bound">u</a><a name="14888" class="DottedPattern Symbol">)</a><a name="14889" class="Symbol">)</a><a name="14890"> </a><a name="14891" class="Symbol">|</a><a name="14892"> </a><a name="14893" class="InductiveConstructor">yes</a><a name="14896"> </a><a name="14897" class="Symbol">(</a><a name="14898" href="#14898" class="Bound">σ</a><a name="14899"> </a><a name="14900" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="14901"> </a><a name="14902" href="#14902" class="Bound">τ</a><a name="14903" class="Symbol">)</a><a name="14904"> </a><a name="14905" href="#14905" class="Bound">t</a><a name="14906"> </a><a name="14907" class="Symbol">|</a><a name="14908"> </a><a name="14909" class="InductiveConstructor">yes</a><a name="14912"> </a><a name="14913" class="DottedPattern Symbol">.</a><a name="14914" href="#14898" class="DottedPattern Bound">σ</a><a name="14915"> </a><a name="14916" href="#14916" class="Bound">u</a><a name="14917"> </a><a name="14918" class="Symbol">|</a><a name="14919"> </a><a name="14920" class="InductiveConstructor">yes</a><a name="14923"> </a><a name="14924" class="InductiveConstructor">refl</a><a name="14928"> </a><a name="14929" class="Symbol">=</a><a name="14930"> </a><a name="14931" href="#11428" class="InductiveConstructor">yes</a><a name="14934"> </a><a name="14935" href="#14902" class="Bound">τ</a><a name="14936"> </a><a name="14937" class="Symbol">(</a><a name="14938" href="#14905" class="Bound">t</a><a name="14939"> </a><a name="14940" href="#7270" class="InductiveConstructor Operator">·</a><a name="14941"> </a><a name="14942" href="#14916" class="Bound">u</a><a name="14943" class="Symbol">)</a><a name="14944">
</a><a name="14945" href="#12537" class="Function">check</a><a name="14950"> </a><a name="14951" href="#14951" class="Bound">Γ</a><a name="14952"> </a><a name="14953" class="Symbol">(</a><a name="14954" class="DottedPattern Symbol">.(</a><a name="14956" href="#8452" class="DottedPattern Function">erase</a><a name="14961"> </a><a name="14962" href="#14993" class="DottedPattern Bound">t</a><a name="14963" class="DottedPattern Symbol">)</a><a name="14964"> </a><a name="14965" class="InductiveConstructor Operator">·</a><a name="14966"> </a><a name="14967" class="DottedPattern Symbol">.(</a><a name="14969" href="#8452" class="DottedPattern Function">erase</a><a name="14974"> </a><a name="14975" href="#15004" class="DottedPattern Bound">u</a><a name="14976" class="DottedPattern Symbol">)</a><a name="14977" class="Symbol">)</a><a name="14978"> </a><a name="14979" class="Symbol">|</a><a name="14980"> </a><a name="14981" class="InductiveConstructor">yes</a><a name="14984"> </a><a name="14985" class="Symbol">(</a><a name="14986" href="#14986" class="Bound">σ</a><a name="14987"> </a><a name="14988" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="14989"> </a><a name="14990" href="#14990" class="Bound">τ</a><a name="14991" class="Symbol">)</a><a name="14992"> </a><a name="14993" href="#14993" class="Bound">t</a><a name="14994"> </a><a name="14995" class="Symbol">|</a><a name="14996"> </a><a name="14997" class="InductiveConstructor">yes</a><a name="15000"> </a><a name="15001" href="#15001" class="Bound">σ′</a><a name="15003"> </a><a name="15004" href="#15004" class="Bound">u</a><a name="15005"> </a><a name="15006" class="Symbol">|</a><a name="15007"> </a><a name="15008" class="InductiveConstructor">no</a><a name="15010">  </a><a name="15012" class="Symbol">_</a><a name="15013">    </a><a name="15017" class="Symbol">=</a><a name="15018"> </a><a name="15019" href="#11482" class="InductiveConstructor">no</a><a name="15021">
</a><a name="15022" href="#12537" class="CatchallClause Function">check</a><a name="15027" class="CatchallClause"> </a><a name="15028" href="#15028" class="CatchallClause Bound">Γ</a><a name="15029" class="CatchallClause"> </a><a name="15030" class="CatchallClause Symbol">(</a><a name="15031" href="#15031" class="CatchallClause Bound">t</a><a name="15032" class="CatchallClause"> </a><a name="15033" class="CatchallClause InductiveConstructor Operator">·</a><a name="15034" class="CatchallClause"> </a><a name="15035" href="#15035" class="CatchallClause Bound">u</a><a name="15036" class="CatchallClause Symbol">)</a><a name="15037" class="CatchallClause">                   </a><a name="15056" class="CatchallClause Symbol">|</a><a name="15057" class="CatchallClause"> </a><a name="15058" class="CatchallClause Symbol">_</a><a name="15059" class="CatchallClause">             </a><a name="15072" class="CatchallClause Symbol">|</a><a name="15073" class="CatchallClause"> </a><a name="15074" class="CatchallClause Symbol">_</a><a name="15075">       </a><a name="15082" class="Symbol">=</a><a name="15083"> </a><a name="15084" href="#11482" class="InductiveConstructor">no</a><a name="15086">
</a></code></pre>
<p>Finally, with λs, we check that the body of the function is well typed in the context plus the type of the argument. If that’s the case, the resulting type is an arrow type:</p>
<pre class="Agda"><code><a name="15275" class="Markup"></a><a name="15287">
</a><a name="15288" href="#12537" class="Function">check</a><a name="15293"> </a><a name="15294" href="#15294" class="Bound">Γ</a><a name="15295"> </a><a name="15296" class="Symbol">(</a><a name="15297" href="#5038" class="InductiveConstructor">lam</a><a name="15300"> </a><a name="15301" href="#15301" class="Bound">σ</a><a name="15302"> </a><a name="15303" href="#15303" class="Bound">t</a><a name="15304" class="Symbol">)</a><a name="15305"> </a><a name="15306" class="Keyword">with</a><a name="15310"> </a><a name="15311" href="#12537" class="Function">check</a><a name="15316"> </a><a name="15317" class="Symbol">(</a><a name="15318" href="#15301" class="Bound">σ</a><a name="15319"> </a><a name="15320" class="InductiveConstructor Operator">∷</a><a name="15321"> </a><a name="15322" href="#15294" class="Bound">Γ</a><a name="15323" class="Symbol">)</a><a name="15324"> </a><a name="15325" href="#15303" class="Bound">t</a><a name="15326">
</a><a name="15327" href="#12537" class="Function">check</a><a name="15332"> </a><a name="15333" href="#15333" class="Bound">Γ</a><a name="15334"> </a><a name="15335" class="Symbol">(</a><a name="15336" class="InductiveConstructor">lam</a><a name="15339"> </a><a name="15340" href="#15340" class="Bound">σ</a><a name="15341"> </a><a name="15342" class="DottedPattern Symbol">.(</a><a name="15344" href="#8452" class="DottedPattern Function">erase</a><a name="15349"> </a><a name="15350" href="#15362" class="DottedPattern Bound">t</a><a name="15351" class="DottedPattern Symbol">)</a><a name="15352" class="Symbol">)</a><a name="15353"> </a><a name="15354" class="Symbol">|</a><a name="15355"> </a><a name="15356" href="#11428" class="InductiveConstructor">yes</a><a name="15359"> </a><a name="15360" href="#15360" class="Bound">τ</a><a name="15361"> </a><a name="15362" href="#15362" class="Bound">t</a><a name="15363"> </a><a name="15364" class="Symbol">=</a><a name="15365"> </a><a name="15366" href="#11428" class="InductiveConstructor">yes</a><a name="15369"> </a><a name="15370" class="Symbol">(</a><a name="15371" href="#15340" class="Bound">σ</a><a name="15372"> </a><a name="15373" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="15374"> </a><a name="15375" href="#15360" class="Bound">τ</a><a name="15376" class="Symbol">)</a><a name="15377"> </a><a name="15378" class="Symbol">(</a><a name="15379" href="#7325" class="InductiveConstructor">lam</a><a name="15382"> </a><a name="15383" href="#15340" class="Bound">σ</a><a name="15384"> </a><a name="15385" href="#15362" class="Bound">t</a><a name="15386" class="Symbol">)</a><a name="15387">
</a><a name="15388" href="#12537" class="Function">check</a><a name="15393"> </a><a name="15394" href="#15394" class="Bound">Γ</a><a name="15395"> </a><a name="15396" class="Symbol">(</a><a name="15397" class="InductiveConstructor">lam</a><a name="15400"> </a><a name="15401" href="#15401" class="Bound">σ</a><a name="15402"> </a><a name="15403" href="#15403" class="Bound">t</a><a name="15404" class="Symbol">)</a><a name="15405">          </a><a name="15415" class="Symbol">|</a><a name="15416"> </a><a name="15417" href="#11482" class="InductiveConstructor">no</a><a name="15419">      </a><a name="15425" class="Symbol">=</a><a name="15426"> </a><a name="15427" href="#11482" class="InductiveConstructor">no</a><a name="15429">
</a></code></pre>
<p>Type checking the syntax for <code>double</code> will give good results:</p>
<pre><code>&gt; C-c C-n check [] (lam nat (var 0 ⊕ var 0))
yes (nat ⇒ nat) (lam nat (var zero refl ⊕ var zero refl))</code></pre>
<p>While ill-typed examples will fail:</p>
<pre><code>&gt; C-c C-n check [] (lam nat (var 0 · var 0))
no

&gt; C-c C-n check [] (lam (nat ⇒ nat) (var 0 ⊕ var 0))
no</code></pre>
<h2 id="embedding-terms">Embedding terms <a href="#embedding-terms" class="section-link">#</a></h2>
<p>Now that we have a type checker, we can embed typed terms into Agda. This technique is a common and cheap way to give semantics to programming languages that we are modelling inside a theorem prover—we borrow the host language semantics.</p>
<p>In our case, we can easily define a function taking <code>Type</code> into Agda’s <code>Set</code>:</p>
<pre class="Agda"><code><a name="16116" class="Markup"></a><a name="16128">
</a><a name="16129" href="#16129" class="Function Operator">⟦_⟧</a><a name="16132"> </a><a name="16133" class="Symbol">:</a><a name="16134"> </a><a name="16135" href="#3798" class="Datatype">Type</a><a name="16139"> </a><a name="16140" class="Symbol">→</a><a name="16141"> </a><a name="16142" class="PrimitiveType">Set</a><a name="16145">
</a><a name="16146" href="#16129" class="Function Operator">⟦</a><a name="16147"> </a><a name="16148" href="#3817" class="InductiveConstructor">nat</a><a name="16151">   </a><a name="16154" href="#16129" class="Function Operator">⟧</a><a name="16155"> </a><a name="16156" class="Symbol">=</a><a name="16157"> </a><a name="16158" class="Datatype">ℕ</a><a name="16159">
</a><a name="16160" href="#16129" class="Function Operator">⟦</a><a name="16161"> </a><a name="16162" href="#16162" class="Bound">σ</a><a name="16163"> </a><a name="16164" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="16165"> </a><a name="16166" href="#16166" class="Bound">τ</a><a name="16167"> </a><a name="16168" href="#16129" class="Function Operator">⟧</a><a name="16169"> </a><a name="16170" class="Symbol">=</a><a name="16171"> </a><a name="16172" href="#16129" class="Function Operator">⟦</a><a name="16173"> </a><a name="16174" href="#16162" class="Bound">σ</a><a name="16175"> </a><a name="16176" href="#16129" class="Function Operator">⟧</a><a name="16177"> </a><a name="16178" class="Symbol">→</a><a name="16179"> </a><a name="16180" href="#16129" class="Function Operator">⟦</a><a name="16181"> </a><a name="16182" href="#16166" class="Bound">τ</a><a name="16183"> </a><a name="16184" href="#16129" class="Function Operator">⟧</a><a name="16185">
</a></code></pre>
<p>Then, to transport an arbitrary <code>Term Γ τ</code> to <code>⟦ τ ⟧</code>, we need an environment storing values for the bound variables:</p>
<pre class="Agda"><code><a name="16317" class="Markup"></a><a name="16329">
</a><a name="16330" class="Keyword">infixr</a><a name="16336"> </a><a name="16337" class="Number">5</a><a name="16338"> </a><a name="16339" href="#16397" class="InductiveConstructor Operator">_∷_</a><a name="16342">
</a><a name="16343" class="Keyword">data</a><a name="16347"> </a><a name="16348" href="#16348" class="Datatype">Env</a><a name="16351"> </a><a name="16352" class="Symbol">:</a><a name="16353"> </a><a name="16354" class="Symbol">∀</a><a name="16355"> </a><a name="16356" class="Symbol">{</a><a name="16357" href="#16357" class="Bound">n</a><a name="16358" class="Symbol">}</a><a name="16359"> </a><a name="16360" class="Symbol">→</a><a name="16361"> </a><a name="16362" href="#6804" class="Function">Ctx</a><a name="16365"> </a><a name="16366" href="#16357" class="Bound">n</a><a name="16367"> </a><a name="16368" class="Symbol">→</a><a name="16369"> </a><a name="16370" class="PrimitiveType">Set</a><a name="16373"> </a><a name="16374" class="Keyword">where</a><a name="16379">
  </a><a name="16382" href="#16382" class="InductiveConstructor">[]</a><a name="16384">  </a><a name="16386" class="Symbol">:</a><a name="16387"> </a><a name="16388" href="#16348" class="Datatype">Env</a><a name="16391"> </a><a name="16392" class="InductiveConstructor">[]</a><a name="16394">
  </a><a name="16397" href="#16397" class="InductiveConstructor Operator">_∷_</a><a name="16400"> </a><a name="16401" class="Symbol">:</a><a name="16402"> </a><a name="16403" class="Symbol">∀</a><a name="16404"> </a><a name="16405" class="Symbol">{</a><a name="16406" href="#16406" class="Bound">n</a><a name="16407" class="Symbol">}</a><a name="16408"> </a><a name="16409" class="Symbol">{</a><a name="16410" href="#16410" class="Bound">Γ</a><a name="16411"> </a><a name="16412" class="Symbol">:</a><a name="16413"> </a><a name="16414" href="#6804" class="Function">Ctx</a><a name="16417"> </a><a name="16418" href="#16406" class="Bound">n</a><a name="16419" class="Symbol">}</a><a name="16420"> </a><a name="16421" class="Symbol">{</a><a name="16422" href="#16422" class="Bound">τ</a><a name="16423" class="Symbol">}</a><a name="16424"> </a><a name="16425" class="Symbol">→</a><a name="16426"> </a><a name="16427" href="#16129" class="Function Operator">⟦</a><a name="16428"> </a><a name="16429" href="#16422" class="Bound">τ</a><a name="16430"> </a><a name="16431" href="#16129" class="Function Operator">⟧</a><a name="16432"> </a><a name="16433" class="Symbol">→</a><a name="16434"> </a><a name="16435" href="#16348" class="Datatype">Env</a><a name="16438"> </a><a name="16439" href="#16410" class="Bound">Γ</a><a name="16440"> </a><a name="16441" class="Symbol">→</a><a name="16442"> </a><a name="16443" href="#16348" class="Datatype">Env</a><a name="16446"> </a><a name="16447" class="Symbol">(</a><a name="16448" href="#16422" class="Bound">τ</a><a name="16449"> </a><a name="16450" class="InductiveConstructor Operator">∷</a><a name="16451"> </a><a name="16452" href="#16410" class="Bound">Γ</a><a name="16453" class="Symbol">)</a><a name="16454">
</a></code></pre>
<p><code>Env Γ</code> stores values corresponding to the types stored in <code>Γ</code>. We can extend an existing <code>Env</code> by consing a value of the right type to it, and extending the context.</p>
<p>We can also lookup values into the <code>Env</code> just like we can index into <code>Vec</code>s:</p>
<pre class="Agda"><code><a name="16714" class="Markup"></a><a name="16726">
</a><a name="16727" href="#16727" class="Function">lookupEnv</a><a name="16736"> </a><a name="16737" class="Symbol">:</a><a name="16738"> </a><a name="16739" class="Symbol">∀</a><a name="16740"> </a><a name="16741" class="Symbol">{</a><a name="16742" href="#16742" class="Bound">n</a><a name="16743" class="Symbol">}</a><a name="16744"> </a><a name="16745" class="Symbol">{</a><a name="16746" href="#16746" class="Bound">Γ</a><a name="16747"> </a><a name="16748" class="Symbol">:</a><a name="16749"> </a><a name="16750" href="#6804" class="Function">Ctx</a><a name="16753"> </a><a name="16754" href="#16742" class="Bound">n</a><a name="16755" class="Symbol">}</a><a name="16756"> </a><a name="16757" class="Symbol">(</a><a name="16758" href="#16758" class="Bound">m</a><a name="16759"> </a><a name="16760" class="Symbol">:</a><a name="16761"> </a><a name="16762" class="Datatype">Fin</a><a name="16765"> </a><a name="16766" href="#16742" class="Bound">n</a><a name="16767" class="Symbol">)</a><a name="16768"> </a><a name="16769" class="Symbol">→</a><a name="16770"> </a><a name="16771" href="#16348" class="Datatype">Env</a><a name="16774"> </a><a name="16775" href="#16746" class="Bound">Γ</a><a name="16776"> </a><a name="16777" class="Symbol">→</a><a name="16778"> </a><a name="16779" href="#16129" class="Function Operator">⟦</a><a name="16780"> </a><a name="16781" class="Function">lookup</a><a name="16787"> </a><a name="16788" href="#16758" class="Bound">m</a><a name="16789"> </a><a name="16790" href="#16746" class="Bound">Γ</a><a name="16791"> </a><a name="16792" href="#16129" class="Function Operator">⟧</a><a name="16793">
</a><a name="16794" href="#16727" class="Function">lookupEnv</a><a name="16803"> </a><a name="16804" class="InductiveConstructor">zero</a><a name="16808">    </a><a name="16812" class="Symbol">(</a><a name="16813" href="#16813" class="Bound">x</a><a name="16814"> </a><a name="16815" href="#16397" class="InductiveConstructor Operator">∷</a><a name="16816"> </a><a name="16817" class="Symbol">_)</a><a name="16819">   </a><a name="16822" class="Symbol">=</a><a name="16823"> </a><a name="16824" href="#16813" class="Bound">x</a><a name="16825">
</a><a name="16826" href="#16727" class="Function">lookupEnv</a><a name="16835"> </a><a name="16836" class="Symbol">(</a><a name="16837" class="InductiveConstructor">suc</a><a name="16840"> </a><a name="16841" href="#16841" class="Bound">n</a><a name="16842" class="Symbol">)</a><a name="16843"> </a><a name="16844" class="Symbol">(_</a><a name="16846"> </a><a name="16847" href="#16397" class="InductiveConstructor Operator">∷</a><a name="16848"> </a><a name="16849" href="#16849" class="Bound">env</a><a name="16852" class="Symbol">)</a><a name="16853"> </a><a name="16854" class="Symbol">=</a><a name="16855"> </a><a name="16856" href="#16727" class="Function">lookupEnv</a><a name="16865"> </a><a name="16866" href="#16841" class="Bound">n</a><a name="16867"> </a><a name="16868" href="#16849" class="Bound">env</a><a name="16871">
</a></code></pre>
<p>With these tools, we can define a function evaluating a <code>Term</code> into an Agda value of the right type:</p>
<pre class="Agda"><code><a name="16986" class="Markup"></a><a name="16998">
</a><a name="16999" href="#16999" class="Function Operator">_[_]</a><a name="17003"> </a><a name="17004" class="Symbol">:</a><a name="17005"> </a><a name="17006" class="Symbol">∀</a><a name="17007"> </a><a name="17008" class="Symbol">{</a><a name="17009" href="#17009" class="Bound">n</a><a name="17010" class="Symbol">}</a><a name="17011"> </a><a name="17012" class="Symbol">{</a><a name="17013" href="#17013" class="Bound">Γ</a><a name="17014"> </a><a name="17015" class="Symbol">:</a><a name="17016"> </a><a name="17017" href="#6804" class="Function">Ctx</a><a name="17020"> </a><a name="17021" href="#17009" class="Bound">n</a><a name="17022" class="Symbol">}</a><a name="17023"> </a><a name="17024" class="Symbol">{</a><a name="17025" href="#17025" class="Bound">τ</a><a name="17026" class="Symbol">}</a><a name="17027"> </a><a name="17028" class="Symbol">→</a><a name="17029"> </a><a name="17030" href="#16348" class="Datatype">Env</a><a name="17033"> </a><a name="17034" href="#17013" class="Bound">Γ</a><a name="17035"> </a><a name="17036" class="Symbol">→</a><a name="17037"> </a><a name="17038" href="#7106" class="Datatype">Term</a><a name="17042"> </a><a name="17043" href="#17013" class="Bound">Γ</a><a name="17044"> </a><a name="17045" href="#17025" class="Bound">τ</a><a name="17046"> </a><a name="17047" class="Symbol">→</a><a name="17048"> </a><a name="17049" href="#16129" class="Function Operator">⟦</a><a name="17050"> </a><a name="17051" href="#17025" class="Bound">τ</a><a name="17052"> </a><a name="17053" href="#16129" class="Function Operator">⟧</a><a name="17054">
</a><a name="17055" href="#17055" class="Bound">env</a><a name="17058"> </a><a name="17059" href="#16999" class="Function Operator">[</a><a name="17060"> </a><a name="17061" href="#7148" class="InductiveConstructor">var</a><a name="17064"> </a><a name="17065" href="#17065" class="Bound">v</a><a name="17066"> </a><a name="17067" class="InductiveConstructor">refl</a><a name="17071"> </a><a name="17072" href="#16999" class="Function Operator">]</a><a name="17073"> </a><a name="17074" class="Symbol">=</a><a name="17075"> </a><a name="17076" href="#16727" class="Function">lookupEnv</a><a name="17085"> </a><a name="17086" href="#17065" class="Bound">v</a><a name="17087"> </a><a name="17088" href="#17055" class="Bound">env</a><a name="17091">
</a><a name="17092" href="#17092" class="Bound">env</a><a name="17095"> </a><a name="17096" href="#16999" class="Function Operator">[</a><a name="17097"> </a><a name="17098" href="#7202" class="InductiveConstructor">lit</a><a name="17101"> </a><a name="17102" href="#17102" class="Bound">n</a><a name="17103">      </a><a name="17109" href="#16999" class="Function Operator">]</a><a name="17110"> </a><a name="17111" class="Symbol">=</a><a name="17112"> </a><a name="17113" href="#17102" class="Bound">n</a><a name="17114">
</a><a name="17115" href="#17115" class="Bound">env</a><a name="17118"> </a><a name="17119" href="#16999" class="Function Operator">[</a><a name="17120"> </a><a name="17121" href="#17121" class="Bound">t</a><a name="17122"> </a><a name="17123" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="17124"> </a><a name="17125" href="#17125" class="Bound">u</a><a name="17126">      </a><a name="17132" href="#16999" class="Function Operator">]</a><a name="17133"> </a><a name="17134" class="Symbol">=</a><a name="17135"> </a><a name="17136" href="#17115" class="Bound">env</a><a name="17139"> </a><a name="17140" href="#16999" class="Function Operator">[</a><a name="17141"> </a><a name="17142" href="#17121" class="Bound">t</a><a name="17143"> </a><a name="17144" href="#16999" class="Function Operator">]</a><a name="17145"> </a><a name="17146" class="Primitive Operator">+</a><a name="17147"> </a><a name="17148" href="#17115" class="Bound">env</a><a name="17151"> </a><a name="17152" href="#16999" class="Function Operator">[</a><a name="17153"> </a><a name="17154" href="#17125" class="Bound">u</a><a name="17155"> </a><a name="17156" href="#16999" class="Function Operator">]</a><a name="17157">
</a><a name="17158" href="#17158" class="Bound">env</a><a name="17161"> </a><a name="17162" href="#16999" class="Function Operator">[</a><a name="17163"> </a><a name="17164" href="#17164" class="Bound">t</a><a name="17165"> </a><a name="17166" href="#7270" class="InductiveConstructor Operator">·</a><a name="17167"> </a><a name="17168" href="#17168" class="Bound">u</a><a name="17169">      </a><a name="17175" href="#16999" class="Function Operator">]</a><a name="17176"> </a><a name="17177" class="Symbol">=</a><a name="17178"> </a><a name="17179" class="Symbol">(</a><a name="17180" href="#17158" class="Bound">env</a><a name="17183"> </a><a name="17184" href="#16999" class="Function Operator">[</a><a name="17185"> </a><a name="17186" href="#17164" class="Bound">t</a><a name="17187"> </a><a name="17188" href="#16999" class="Function Operator">]</a><a name="17189" class="Symbol">)</a><a name="17190"> </a><a name="17191" class="Symbol">(</a><a name="17192" href="#17158" class="Bound">env</a><a name="17195"> </a><a name="17196" href="#16999" class="Function Operator">[</a><a name="17197"> </a><a name="17198" href="#17168" class="Bound">u</a><a name="17199"> </a><a name="17200" href="#16999" class="Function Operator">]</a><a name="17201" class="Symbol">)</a><a name="17202">
</a><a name="17203" href="#17203" class="Bound">env</a><a name="17206"> </a><a name="17207" href="#16999" class="Function Operator">[</a><a name="17208"> </a><a name="17209" href="#7325" class="InductiveConstructor">lam</a><a name="17212"> </a><a name="17213" class="Symbol">_</a><a name="17214"> </a><a name="17215" href="#17215" class="Bound">t</a><a name="17216">    </a><a name="17220" href="#16999" class="Function Operator">]</a><a name="17221"> </a><a name="17222" class="Symbol">=</a><a name="17223"> </a><a name="17224" class="Symbol">λ</a><a name="17225"> </a><a name="17226" href="#17226" class="Bound">x</a><a name="17227"> </a><a name="17228" class="Symbol">→</a><a name="17229"> </a><a name="17230" class="Symbol">(</a><a name="17231" href="#17226" class="Bound">x</a><a name="17232"> </a><a name="17233" href="#16397" class="InductiveConstructor Operator">∷</a><a name="17234"> </a><a name="17235" href="#17203" class="Bound">env</a><a name="17238" class="Symbol">)</a><a name="17239"> </a><a name="17240" href="#16999" class="Function Operator">[</a><a name="17241"> </a><a name="17242" href="#17215" class="Bound">t</a><a name="17243"> </a><a name="17244" href="#16999" class="Function Operator">]</a><a name="17245">
</a></code></pre>
<p>Now we can verify, for example, that <code>double</code> does the right thing:</p>
<pre class="Agda"><code><a name="17327" class="Markup"></a><a name="17339">
</a><a name="17340" href="#17340" class="Function">double′</a><a name="17347"> </a><a name="17348" class="Symbol">:</a><a name="17349"> </a><a name="17350" href="#16129" class="Function Operator">⟦</a><a name="17351"> </a><a name="17352" href="#3817" class="InductiveConstructor">nat</a><a name="17355"> </a><a name="17356" href="#3830" class="InductiveConstructor Operator">⇒</a><a name="17357"> </a><a name="17358" href="#3817" class="InductiveConstructor">nat</a><a name="17361"> </a><a name="17362" href="#16129" class="Function Operator">⟧</a><a name="17363">
</a><a name="17364" href="#17340" class="Function">double′</a><a name="17371"> </a><a name="17372" class="Symbol">=</a><a name="17373"> </a><a name="17374" href="#16382" class="InductiveConstructor">[]</a><a name="17376"> </a><a name="17377" href="#16999" class="Function Operator">[</a><a name="17378"> </a><a name="17379" href="#8252" class="Function">double</a><a name="17385"> </a><a name="17386" href="#16999" class="Function Operator">]</a><a name="17387"> </a><a name="17388" class="Comment">-- A closed term, in an empty environment</a><a name="17429">

</a><a name="17431" href="#17431" class="Function">doubleTest</a><a name="17441"> </a><a name="17442" class="Symbol">:</a><a name="17443"> </a><a name="17444" href="#17340" class="Function">double′</a><a name="17451"> </a><a name="17452" class="Number">3</a><a name="17453"> </a><a name="17454" class="Datatype Operator">≡</a><a name="17455"> </a><a name="17456" class="Number">6</a><a name="17457">
</a><a name="17458" href="#17431" class="Function">doubleTest</a><a name="17468"> </a><a name="17469" class="Symbol">=</a><a name="17470"> </a><a name="17471" class="InductiveConstructor">refl</a><a name="17475">
</a></code></pre>
<h2 id="constant-folding">Constant folding <a href="#constant-folding" class="section-link">#</a></h2>
<p>To conclude, we will write a simple optimisation our terms, and prove that it is sound by showing that it always preserves the semantics of the original term, using the embedding above.</p>
<p>To represent “optimised” terms, we will use a record parametrised over the original term and holding the optimised version, plus evidence that for all environments evaluating the original and optimised term will yield the same Agda value:</p>
<pre class="Agda"><code><a name="17936" class="Markup"></a><a name="17948">
</a><a name="17949" class="Keyword">record</a><a name="17955"> </a><a name="17956" href="#17956" class="Record">Optimised</a><a name="17965"> </a><a name="17966" class="Symbol">{</a><a name="17967" href="#17967" class="Bound">n</a><a name="17968" class="Symbol">}</a><a name="17969"> </a><a name="17970" class="Symbol">{</a><a name="17971" href="#17971" class="Bound">Γ</a><a name="17972"> </a><a name="17973" class="Symbol">:</a><a name="17974"> </a><a name="17975" href="#6804" class="Function">Ctx</a><a name="17978"> </a><a name="17979" href="#17967" class="Bound">n</a><a name="17980" class="Symbol">}</a><a name="17981"> </a><a name="17982" class="Symbol">{</a><a name="17983" href="#17983" class="Bound">σ</a><a name="17984" class="Symbol">}</a><a name="17985"> </a><a name="17986" class="Symbol">(</a><a name="17987" href="#17987" class="Bound">t</a><a name="17988"> </a><a name="17989" class="Symbol">:</a><a name="17990"> </a><a name="17991" href="#7106" class="Datatype">Term</a><a name="17995"> </a><a name="17996" href="#17971" class="Bound">Γ</a><a name="17997"> </a><a name="17998" href="#17983" class="Bound">σ</a><a name="17999" class="Symbol">)</a><a name="18000"> </a><a name="18001" class="Symbol">:</a><a name="18002"> </a><a name="18003" class="PrimitiveType">Set</a><a name="18006"> </a><a name="18007" class="Keyword">where</a><a name="18012">
  </a><a name="18015" class="Keyword">constructor</a><a name="18026"> </a><a name="18027" href="#18027" class="InductiveConstructor">opt</a><a name="18030">
  </a><a name="18033" class="Keyword">field</a><a name="18038">
    </a><a name="18043" href="#18043" class="Field">optimised</a><a name="18052"> </a><a name="18053" class="Symbol">:</a><a name="18054"> </a><a name="18055" href="#7106" class="Datatype">Term</a><a name="18059"> </a><a name="18060" href="#17971" class="Bound">Γ</a><a name="18061"> </a><a name="18062" href="#17983" class="Bound">σ</a><a name="18063">
    </a><a name="18068" href="#18068" class="Field">sound</a><a name="18073">     </a><a name="18078" class="Symbol">:</a><a name="18079"> </a><a name="18080" class="Symbol">∀</a><a name="18081"> </a><a name="18082" class="Symbol">{</a><a name="18083" href="#18083" class="Bound">env</a><a name="18086" class="Symbol">}</a><a name="18087"> </a><a name="18088" class="Symbol">→</a><a name="18089"> </a><a name="18090" href="#18083" class="Bound">env</a><a name="18093"> </a><a name="18094" href="#16999" class="Function Operator">[</a><a name="18095"> </a><a name="18096" href="#17987" class="Bound">t</a><a name="18097"> </a><a name="18098" href="#16999" class="Function Operator">]</a><a name="18099"> </a><a name="18100" class="Datatype Operator">≡</a><a name="18101"> </a><a name="18102" href="#18083" class="Bound">env</a><a name="18105"> </a><a name="18106" href="#16999" class="Function Operator">[</a><a name="18107"> </a><a name="18108" href="#18043" class="Field">optimised</a><a name="18117"> </a><a name="18118" href="#16999" class="Function Operator">]</a><a name="18119">
</a></code></pre>
<p>However, to succeed, we need to postulate an axiom:</p>
<pre class="Agda"><code><a name="18185" class="Markup"></a><a name="18197">
</a><a name="18198" class="Keyword">postulate</a><a name="18207"> </a><a name="18208" href="#18208" class="Postulate">ext</a><a name="18211"> </a><a name="18212" class="Symbol">:</a><a name="18213"> </a><a name="18214" class="Symbol">∀</a><a name="18215"> </a><a name="18216" class="Symbol">{</a><a name="18217" href="#18217" class="Bound">A</a><a name="18218"> </a><a name="18219" href="#18219" class="Bound">B</a><a name="18220"> </a><a name="18221" class="Symbol">:</a><a name="18222"> </a><a name="18223" class="PrimitiveType">Set</a><a name="18226" class="Symbol">}</a><a name="18227"> </a><a name="18228" class="Symbol">{</a><a name="18229" href="#18229" class="Bound">f</a><a name="18230"> </a><a name="18231" href="#18231" class="Bound">g</a><a name="18232"> </a><a name="18233" class="Symbol">:</a><a name="18234"> </a><a name="18235" href="#18217" class="Bound">A</a><a name="18236"> </a><a name="18237" class="Symbol">→</a><a name="18238"> </a><a name="18239" href="#18219" class="Bound">B</a><a name="18240" class="Symbol">}</a><a name="18241"> </a><a name="18242" class="Symbol">→</a><a name="18243"> </a><a name="18244" class="Symbol">({</a><a name="18246" href="#18246" class="Bound">x</a><a name="18247"> </a><a name="18248" class="Symbol">:</a><a name="18249"> </a><a name="18250" href="#18217" class="Bound">A</a><a name="18251" class="Symbol">}</a><a name="18252"> </a><a name="18253" class="Symbol">→</a><a name="18254"> </a><a name="18255" href="#18229" class="Bound">f</a><a name="18256"> </a><a name="18257" href="#18246" class="Bound">x</a><a name="18258"> </a><a name="18259" class="Datatype Operator">≡</a><a name="18260"> </a><a name="18261" href="#18231" class="Bound">g</a><a name="18262"> </a><a name="18263" href="#18246" class="Bound">x</a><a name="18264" class="Symbol">)</a><a name="18265"> </a><a name="18266" class="Symbol">→</a><a name="18267"> </a><a name="18268" href="#18229" class="Bound">f</a><a name="18269"> </a><a name="18270" class="Datatype Operator">≡</a><a name="18271"> </a><a name="18272" href="#18231" class="Bound">g</a><a name="18273">
</a></code></pre>
<p>This axiom says that if we have two functions <code>f</code> and <code>g</code>, and we have evidence that for all inputs the functions have equal outputs, then the functions themselves can be considered equal. This is usually know as <a href="http://en.wikipedia.org/wiki/Extensionality"><em>functional extensionality</em></a>, and we cannot prove it in Agda and theorem provers based on similar theories.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Postulating extensionality is still (hopefully) consistent with Agda’s theory, although obviously we will not be able to compute with it—definitions pattern matching on equality proofs will get stuck on invocations of <code>ext</code>.</p>
<p>With this axiom and our record <code>Optimised</code>, we will write the optimisation and the proof at the same time. The optimisation will consist of reducing constant expressions to number literals, so that for example</p>
<pre><code>lit 3 ⊕ lit 7</code></pre>
<p>will be reduced to</p>
<pre><code>lit 10</code></pre>
<p>So, our function will take a term and produce an optimised version of it:</p>
<pre class="Agda"><code><a name="19965" class="Markup"></a><a name="19977">
</a><a name="19978" href="#19978" class="Function">cfold</a><a name="19983"> </a><a name="19984" class="Symbol">:</a><a name="19985"> </a><a name="19986" class="Symbol">∀</a><a name="19987"> </a><a name="19988" class="Symbol">{</a><a name="19989" href="#19989" class="Bound">n</a><a name="19990" class="Symbol">}</a><a name="19991"> </a><a name="19992" class="Symbol">{</a><a name="19993" href="#19993" class="Bound">Γ</a><a name="19994"> </a><a name="19995" class="Symbol">:</a><a name="19996"> </a><a name="19997" href="#6804" class="Function">Ctx</a><a name="20000"> </a><a name="20001" href="#19989" class="Bound">n</a><a name="20002" class="Symbol">}</a><a name="20003"> </a><a name="20004" class="Symbol">{</a><a name="20005" href="#20005" class="Bound">τ</a><a name="20006" class="Symbol">}</a><a name="20007"> </a><a name="20008" class="Symbol">(</a><a name="20009" href="#20009" class="Bound">t</a><a name="20010"> </a><a name="20011" class="Symbol">:</a><a name="20012"> </a><a name="20013" href="#7106" class="Datatype">Term</a><a name="20017"> </a><a name="20018" href="#19993" class="Bound">Γ</a><a name="20019"> </a><a name="20020" href="#20005" class="Bound">τ</a><a name="20021" class="Symbol">)</a><a name="20022"> </a><a name="20023" class="Symbol">→</a><a name="20024"> </a><a name="20025" href="#17956" class="Record">Optimised</a><a name="20034"> </a><a name="20035" href="#20009" class="Bound">t</a><a name="20036">
</a></code></pre>
<p>Variables and literals stay untouched, so the proof of equality will be trivial:</p>
<pre class="Agda"><code><a name="20131" class="Markup"></a><a name="20143">
</a><a name="20144" href="#19978" class="Function">cfold</a><a name="20149"> </a><a name="20150" class="Symbol">(</a><a name="20151" href="#7148" class="InductiveConstructor">var</a><a name="20154"> </a><a name="20155" href="#20155" class="Bound">v</a><a name="20156"> </a><a name="20157" href="#20157" class="Bound">p</a><a name="20158" class="Symbol">)</a><a name="20159"> </a><a name="20160" class="Symbol">=</a><a name="20161"> </a><a name="20162" href="#18027" class="InductiveConstructor">opt</a><a name="20165"> </a><a name="20166" class="Symbol">(</a><a name="20167" href="#7148" class="InductiveConstructor">var</a><a name="20170"> </a><a name="20171" href="#20155" class="Bound">v</a><a name="20172"> </a><a name="20173" href="#20157" class="Bound">p</a><a name="20174" class="Symbol">)</a><a name="20175"> </a><a name="20176" class="InductiveConstructor">refl</a><a name="20180">
</a><a name="20181" href="#19978" class="Function">cfold</a><a name="20186"> </a><a name="20187" class="Symbol">(</a><a name="20188" href="#7202" class="InductiveConstructor">lit</a><a name="20191"> </a><a name="20192" href="#20192" class="Bound">x</a><a name="20193" class="Symbol">)</a><a name="20194">   </a><a name="20197" class="Symbol">=</a><a name="20198"> </a><a name="20199" href="#18027" class="InductiveConstructor">opt</a><a name="20202"> </a><a name="20203" class="Symbol">(</a><a name="20204" href="#7202" class="InductiveConstructor">lit</a><a name="20207"> </a><a name="20208" href="#20192" class="Bound">x</a><a name="20209" class="Symbol">)</a><a name="20210">   </a><a name="20213" class="InductiveConstructor">refl</a><a name="20217">
</a></code></pre>
<p>For applications, we call <code>cfold</code> recursively, and then we use <code>cong₂</code> to combine the resulting proofs of soundness—since evaluating functions means applying them, we use <code>_$_</code>:</p>
<pre><code>cong₂ : {A B C : Set} (f : A → B → C) {x y u v} → x ≡ y → u ≡ v → f x u ≡ f y v
_$_   : ∀ {A : Set} {B : A → Set} → ((x : A) → B x) → ((x : A) → B x)
cong₂ _$_ : {A B : Set} {f g : A → B} {x y : A} → f ≡ g → x ≡ y → (f $ x) ≡ (g $ y)</code></pre>
<pre class="Agda"><code><a name="20658" class="Markup"></a><a name="20670">
</a><a name="20671" href="#19978" class="Function">cfold</a><a name="20676"> </a><a name="20677" class="Symbol">(</a><a name="20678" href="#20678" class="Bound">t</a><a name="20679"> </a><a name="20680" href="#7270" class="InductiveConstructor Operator">·</a><a name="20681"> </a><a name="20682" href="#20682" class="Bound">u</a><a name="20683" class="Symbol">)</a><a name="20684"> </a><a name="20685" class="Keyword">with</a><a name="20689"> </a><a name="20690" href="#19978" class="Function">cfold</a><a name="20695"> </a><a name="20696" href="#20678" class="Bound">t</a><a name="20697"> </a><a name="20698" class="Symbol">|</a><a name="20699"> </a><a name="20700" href="#19978" class="Function">cfold</a><a name="20705"> </a><a name="20706" href="#20682" class="Bound">u</a><a name="20707">
</a><a name="20708" class="Symbol">...</a><a name="20711"> </a><a name="20712" class="Symbol">|</a><a name="20713"> </a><a name="20714" href="#18027" class="InductiveConstructor">opt</a><a name="20717"> </a><a name="20718" href="#20718" class="Bound">t′</a><a name="20720"> </a><a name="20721" href="#20721" class="Bound">p</a><a name="20722"> </a><a name="20723" class="Symbol">|</a><a name="20724"> </a><a name="20725" href="#18027" class="InductiveConstructor">opt</a><a name="20728"> </a><a name="20729" href="#20729" class="Bound">u′</a><a name="20731"> </a><a name="20732" href="#20732" class="Bound">q</a><a name="20733"> </a><a name="20734" class="Symbol">=</a><a name="20735"> </a><a name="20736" href="#18027" class="InductiveConstructor">opt</a><a name="20739"> </a><a name="20740" class="Symbol">(</a><a name="20741" href="#20718" class="Bound">t′</a><a name="20743"> </a><a name="20744" href="#7270" class="InductiveConstructor Operator">·</a><a name="20745"> </a><a name="20746" href="#20729" class="Bound">u′</a><a name="20748" class="Symbol">)</a><a name="20749"> </a><a name="20750" class="Symbol">(</a><a name="20751" class="Function">cong₂</a><a name="20756"> </a><a name="20757" class="Function Operator">_$_</a><a name="20760"> </a><a name="20761" href="#20721" class="Bound">p</a><a name="20762"> </a><a name="20763" href="#20732" class="Bound">q</a><a name="20764" class="Symbol">)</a><a name="20765">
</a></code></pre>
<p>For λs, we need to use <code>ext</code> to prove that the optimised function is equal to the original one:</p>
<pre class="Agda"><code><a name="20875" class="Markup"></a><a name="20887">
</a><a name="20888" href="#19978" class="Function">cfold</a><a name="20893"> </a><a name="20894" class="Symbol">(</a><a name="20895" href="#7325" class="InductiveConstructor">lam</a><a name="20898"> </a><a name="20899" href="#20899" class="Bound">σ</a><a name="20900"> </a><a name="20901" href="#20901" class="Bound">t</a><a name="20902" class="Symbol">)</a><a name="20903"> </a><a name="20904" class="Keyword">with</a><a name="20908"> </a><a name="20909" href="#19978" class="Function">cfold</a><a name="20914"> </a><a name="20915" href="#20901" class="Bound">t</a><a name="20916">
</a><a name="20917" class="Symbol">...</a><a name="20920"> </a><a name="20921" class="Symbol">|</a><a name="20922"> </a><a name="20923" href="#18027" class="InductiveConstructor">opt</a><a name="20926"> </a><a name="20927" href="#20927" class="Bound">t′</a><a name="20929"> </a><a name="20930" href="#20930" class="Bound">p</a><a name="20931"> </a><a name="20932" class="Symbol">=</a><a name="20933"> </a><a name="20934" href="#18027" class="InductiveConstructor">opt</a><a name="20937"> </a><a name="20938" class="Symbol">(</a><a name="20939" href="#7325" class="InductiveConstructor">lam</a><a name="20942"> </a><a name="20943" class="Bound">σ</a><a name="20944"> </a><a name="20945" href="#20927" class="Bound">t′</a><a name="20947" class="Symbol">)</a><a name="20948"> </a><a name="20949" class="Symbol">(</a><a name="20950" href="#18208" class="Postulate">ext</a><a name="20953"> </a><a name="20954" href="#20930" class="Bound">p</a><a name="20955" class="Symbol">)</a><a name="20956">
</a></code></pre>
<p>Finally, with additions, we perform the actual optimisation. If both sides after optimisation are number literals we can replace them with another literal. Otherwise we leave the addition in place. We also combine the proofs of equality of the sides with <code>cong₂ _+_</code>, given that the denotation uses <code>_+_</code>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<pre class="Agda"><code><a name="21515" class="Markup"></a><a name="21527">
</a><a name="21528" href="#19978" class="Function">cfold</a><a name="21533"> </a><a name="21534" class="Symbol">(</a><a name="21535" href="#21535" class="Bound">t</a><a name="21536"> </a><a name="21537" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="21538"> </a><a name="21539" href="#21539" class="Bound">u</a><a name="21540" class="Symbol">)</a><a name="21541"> </a><a name="21542" class="Keyword">with</a><a name="21546"> </a><a name="21547" href="#19978" class="Function">cfold</a><a name="21552"> </a><a name="21553" href="#21535" class="Bound">t</a><a name="21554"> </a><a name="21555" class="Symbol">|</a><a name="21556"> </a><a name="21557" href="#19978" class="Function">cfold</a><a name="21562"> </a><a name="21563" href="#21539" class="Bound">u</a><a name="21564">
</a><a name="21565" class="Symbol">...</a><a name="21568"> </a><a name="21569" class="Symbol">|</a><a name="21570"> </a><a name="21571" href="#18027" class="InductiveConstructor">opt</a><a name="21574"> </a><a name="21575" class="Symbol">(</a><a name="21576" href="#7202" class="InductiveConstructor">lit</a><a name="21579"> </a><a name="21580" href="#21580" class="Bound">n</a><a name="21581" class="Symbol">)</a><a name="21582"> </a><a name="21583" href="#21583" class="Bound">p</a><a name="21584"> </a><a name="21585" class="Symbol">|</a><a name="21586"> </a><a name="21587" href="#18027" class="InductiveConstructor">opt</a><a name="21590"> </a><a name="21591" class="Symbol">(</a><a name="21592" href="#7202" class="InductiveConstructor">lit</a><a name="21595"> </a><a name="21596" href="#21596" class="Bound">m</a><a name="21597" class="Symbol">)</a><a name="21598"> </a><a name="21599" href="#21599" class="Bound">q</a><a name="21600"> </a><a name="21601" class="Symbol">=</a><a name="21602"> </a><a name="21603" href="#18027" class="InductiveConstructor">opt</a><a name="21606"> </a><a name="21607" class="Symbol">(</a><a name="21608" href="#7202" class="InductiveConstructor">lit</a><a name="21611"> </a><a name="21612" class="Symbol">(</a><a name="21613" href="#21580" class="Bound">n</a><a name="21614"> </a><a name="21615" class="Primitive Operator">+</a><a name="21616"> </a><a name="21617" href="#21596" class="Bound">m</a><a name="21618" class="Symbol">))</a><a name="21620"> </a><a name="21621" class="Symbol">(</a><a name="21622" class="Function">cong₂</a><a name="21627"> </a><a name="21628" class="Primitive Operator">_+_</a><a name="21631"> </a><a name="21632" href="#21583" class="Bound">p</a><a name="21633"> </a><a name="21634" href="#21599" class="Bound">q</a><a name="21635" class="Symbol">)</a><a name="21636">
</a><a name="21637" class="CatchallClause Symbol">...</a><a name="21640" class="CatchallClause"> </a><a name="21641" class="CatchallClause Symbol">|</a><a name="21642" class="CatchallClause"> </a><a name="21643" href="#18027" class="CatchallClause InductiveConstructor">opt</a><a name="21646" class="CatchallClause"> </a><a name="21647" href="#21647" class="CatchallClause Bound">t′</a><a name="21649" class="CatchallClause">      </a><a name="21655" href="#21655" class="CatchallClause Bound">p</a><a name="21656" class="CatchallClause"> </a><a name="21657" class="CatchallClause Symbol">|</a><a name="21658" class="CatchallClause"> </a><a name="21659" href="#18027" class="CatchallClause InductiveConstructor">opt</a><a name="21662" class="CatchallClause"> </a><a name="21663" href="#21663" class="CatchallClause Bound">u′</a><a name="21665" class="CatchallClause">      </a><a name="21671" href="#21671" class="CatchallClause Bound">q</a><a name="21672"> </a><a name="21673" class="Symbol">=</a><a name="21674"> </a><a name="21675" href="#18027" class="InductiveConstructor">opt</a><a name="21678"> </a><a name="21679" class="Symbol">(</a><a name="21680" href="#21647" class="Bound">t′</a><a name="21682"> </a><a name="21683" href="#7225" class="InductiveConstructor Operator">⊕</a><a name="21684"> </a><a name="21685" href="#21663" class="Bound">u′</a><a name="21687" class="Symbol">)</a><a name="21688"> </a><a name="21689" class="Symbol">(</a><a name="21690" class="Function">cong₂</a><a name="21695"> </a><a name="21696" class="Primitive Operator">_+_</a><a name="21699"> </a><a name="21700" href="#21655" class="Bound">p</a><a name="21701"> </a><a name="21702" href="#21671" class="Bound">q</a><a name="21703" class="Symbol">)</a><a name="21704">
</a></code></pre>
<p>And that’s it.</p>
<p>You can comment this post <a href="http://www.reddit.com/r/haskell/comments/1k3b8u/agda_by_example_lambdacalculus/">on reddit</a>.</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol start="1">
<li id="fn1" role="doc-endnote"><p>See also the Agda version by Ulf Norell in his <a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf"><em>Dependently Typed Programming in Agda</em></a> tutorial, after which some of the data types for this tutorial are patterned after.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>See the footnote ad the end of <a href="#constant-folding">the section about constant folding</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Notice that the <code>no</code> constructor does not include evidence that the term is ill-typed. This could be fixed by having a data type representing ill-typed terms.</p>
<p>Precise types are usually a good idea, not only because they describe the program better to humans, but also because machines can do more with it. For example, when using <a href="http://wiki.portal.chalmers.se/agda/agda.php?n=Main.Auto"><code>Agsy</code></a> with <code>Check</code>, <code>bad</code> is always going to be a valid candidate, even if the term we are checking is well typed.</p>
<p>Here we have chosen a simpler way for brevity, especially since the “error” data type would be fairly boring.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>It has been an ongoing challenge to find a workable theory where functional extensionality holds—a recent proposal is <em><a href="http://www.cs.nott.ac.uk/~txa/publ/obseqnow.pdf">observational equality</a></em>.</p>
<p>With “workable” we mean among other things a theory where type checking is decidable, something that we lose if for example we “solve” the problem in a naïve way by adding a rule to derive definitional equality (the meta-judgement in the type checker for term equality) from propositional equality.</p>
<p>More broadly the theme of equality is a very debated one in type theory, with <a href="http://homotopytypetheory.org/">one related development</a> getting a lot of people excited lately.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>If we had <code>var</code> to have <code>lookup v Γ</code> as an index, we would have been unable to pattern match on the optimised term here, since Agda would have got stuck trying to decide if there should be a case for <code>var</code>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
