---
title: "Agda by Example: Sorting"
date: 2013-04-01
tags: post
---

<h2 id="agda">Agda? <a href="#agda" class="section-link">#</a></h2>
<p>The Haskell programmer is used to the pleasure of collaborating with a nice type system. Haskell itself hits quite a sweet spot of expressivity and manageability—type inference is (mostly) decidable, no subtyping, etc. However, in the past 30 years, new systems have been emerging that allow the user to encode many more properties at the type level. In fact, these systems are so expressive that they are often used as logical frameworks for mathematics rather than to write programs, and are thus often called “theorem provers” rather than “programming languages.” Thanks to <a href="https://en.wikipedia.org/wiki/Curry-Howard">a notorious correspondence</a>, we know that these two activities are really the same.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a> is one of the most prominent systems of this kind at the moment. Many Haskell programmers like it because it has very functional slant, doing everything without recurring to mechanised transformation of terms (of which <a href="http://coq.inria.fr/">Coq</a> is the most famous offender). In this blog I will try to give some examples that will hopefully make you interested. This first post explains how sorting algorithms can be proven correct. The implementation is largely inspired by a <a href="https://personal.cis.strath.ac.uk/~conor/Pivotal.pdf">presentation</a> by Conor McBride.</p>
<p>This blog post was generated from a literate Agda file, that you can find <a href="https://github.com/bitonic/mazzo.li/blob/master/posts/AgdaSort.lagda">here</a>. I’m not going to explain how to install Agda here, you can refer to the <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">wiki</a> or the wonderful <a href="irc://chat.freenode.net/agda">freenode channel</a>. While I go over all concepts presented I won’t go in depth to keep things reasonably brief: this is intended to get a taste of what Agda is capable of rather than explaining all its features. If you want to read a document meant to be a more comprehensive introduction, you can refer to the <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials">many tutorials</a> available—personally I recommend Ulf Norell’s <em>Dependently Typed Programming in Agda</em>.</p>
<p>Let’s get started!</p>
<h2 id="a-few-types">A few types <a href="#a-few-types" class="section-link">#</a></h2>
<h3 id="good-old-lists">Good old <code>List</code>s <a href="#good-old-lists" class="section-link">#</a></h3>
<pre class="Agda"><code><a name="2496" class="Markup"></a><a name="2508">
</a><a name="2509" class="Keyword">module</a><a name="2515"> </a><a name="2516" href="#1" class="Module">AgdaSort</a><a name="2524"> </a><a name="2525" class="Keyword">where</a><a name="2530">
</a></code></pre>
<p>After the module declaration, let’s warm up by defining a data type dear to functional programmers:</p>
<pre class="Agda"><code><a name="2644" class="Markup"></a><a name="2656">
</a><a name="2657" class="Keyword">infixr</a><a name="2663"> </a><a name="2664" class="Number">5</a><a name="2665"> </a><a name="2666" href="#2719" class="InductiveConstructor Operator">_∷_</a><a name="2669">
</a><a name="2670" class="Keyword">data</a><a name="2674"> </a><a name="2675" href="#2675" class="Datatype">List</a><a name="2679"> </a><a name="2680" class="Symbol">(</a><a name="2681" href="#2681" class="Bound">X</a><a name="2682"> </a><a name="2683" class="Symbol">:</a><a name="2684"> </a><a name="2685" class="PrimitiveType">Set</a><a name="2688" class="Symbol">)</a><a name="2689"> </a><a name="2690" class="Symbol">:</a><a name="2691"> </a><a name="2692" class="PrimitiveType">Set</a><a name="2695"> </a><a name="2696" class="Keyword">where</a><a name="2701">
  </a><a name="2704" href="#2704" class="InductiveConstructor">[]</a><a name="2706">  </a><a name="2708" class="Symbol">:</a><a name="2709"> </a><a name="2710" href="#2675" class="Datatype">List</a><a name="2714"> </a><a name="2715" href="#2681" class="Bound">X</a><a name="2716">
  </a><a name="2719" href="#2719" class="InductiveConstructor Operator">_∷_</a><a name="2722"> </a><a name="2723" class="Symbol">:</a><a name="2724"> </a><a name="2725" href="#2681" class="Bound">X</a><a name="2726"> </a><a name="2727" class="Symbol">→</a><a name="2728"> </a><a name="2729" href="#2675" class="Datatype">List</a><a name="2733"> </a><a name="2734" href="#2681" class="Bound">X</a><a name="2735"> </a><a name="2736" class="Symbol">→</a><a name="2737"> </a><a name="2738" href="#2675" class="Datatype">List</a><a name="2742"> </a><a name="2743" href="#2681" class="Bound">X</a><a name="2744">
</a></code></pre>
<p>The syntax to declare this type resembles the syntax for <a href="https://en.wikibooks.org/wiki/Haskell/GADT">GADTs</a> in Haskell. Here <code>X</code> is the parametrised type—what Agda calls <code>Set</code> is more or less what Haskell calls <code>*</code>, the type of types, or “kind” in Haskell parlance. <code>List</code> is a type constructor which takes a type and “returns” a new type, <code>List : Set → Set</code>, much like Haskell’s <code>[] :: * → *</code>.</p>
<p>Then we have two constructors, <code>[]</code> for an empty list and <code>_∷_</code> to cons an element to an existing list. Agda gives us great flexibility in the syntax: arbitrary operators can defined where <code>_</code> indicates an argument, and identifiers are not limited to the usual mix of alphanumeric characters plus a few of symbols. In this case <code>_∷_</code> is a binary operator. The fixity declaration is similar to what we would find in Haskell.</p>
<p>Let’s define <code>foldr</code>:</p>
<pre class="Agda"><code><a name="3609" class="Markup"></a><a name="3621">
</a><a name="3622" href="#3622" class="Function">foldr</a><a name="3627"> </a><a name="3628" class="Symbol">:</a><a name="3629"> </a><a name="3630" class="Symbol">∀</a><a name="3631"> </a><a name="3632" class="Symbol">{</a><a name="3633" href="#3633" class="Bound">A</a><a name="3634" class="Symbol">}</a><a name="3635"> </a><a name="3636" class="Symbol">{</a><a name="3637" href="#3637" class="Bound">B</a><a name="3638"> </a><a name="3639" class="Symbol">:</a><a name="3640"> </a><a name="3641" class="PrimitiveType">Set</a><a name="3644" class="Symbol">}</a><a name="3645"> </a><a name="3646" class="Symbol">→</a><a name="3647"> </a><a name="3648" class="Symbol">(</a><a name="3649" href="#3633" class="Bound">A</a><a name="3650"> </a><a name="3651" class="Symbol">→</a><a name="3652"> </a><a name="3653" href="#3637" class="Bound">B</a><a name="3654"> </a><a name="3655" class="Symbol">→</a><a name="3656"> </a><a name="3657" href="#3637" class="Bound">B</a><a name="3658" class="Symbol">)</a><a name="3659"> </a><a name="3660" class="Symbol">→</a><a name="3661"> </a><a name="3662" href="#3637" class="Bound">B</a><a name="3663"> </a><a name="3664" class="Symbol">→</a><a name="3665"> </a><a name="3666" href="#2675" class="Datatype">List</a><a name="3670"> </a><a name="3671" href="#3633" class="Bound">A</a><a name="3672"> </a><a name="3673" class="Symbol">→</a><a name="3674"> </a><a name="3675" href="#3637" class="Bound">B</a><a name="3676">
</a><a name="3677" href="#3622" class="Function">foldr</a><a name="3682"> </a><a name="3683" href="#3683" class="Bound">f</a><a name="3684"> </a><a name="3685" href="#3685" class="Bound">b</a><a name="3686"> </a><a name="3687" href="#2704" class="InductiveConstructor">[]</a><a name="3689">       </a><a name="3696" class="Symbol">=</a><a name="3697"> </a><a name="3698" href="#3685" class="Bound">b</a><a name="3699">
</a><a name="3700" href="#3622" class="Function">foldr</a><a name="3705"> </a><a name="3706" href="#3706" class="Bound">f</a><a name="3707"> </a><a name="3708" href="#3708" class="Bound">b</a><a name="3709"> </a><a name="3710" class="Symbol">(</a><a name="3711" href="#3711" class="Bound">a</a><a name="3712"> </a><a name="3713" href="#2719" class="InductiveConstructor Operator">∷</a><a name="3714"> </a><a name="3715" href="#3715" class="Bound">as</a><a name="3717" class="Symbol">)</a><a name="3718"> </a><a name="3719" class="Symbol">=</a><a name="3720"> </a><a name="3721" href="#3706" class="Bound">f</a><a name="3722"> </a><a name="3723" href="#3711" class="Bound">a</a><a name="3724"> </a><a name="3725" class="Symbol">(</a><a name="3726" href="#3622" class="Function">foldr</a><a name="3731"> </a><a name="3732" href="#3706" class="Bound">f</a><a name="3733"> </a><a name="3734" href="#3708" class="Bound">b</a><a name="3735"> </a><a name="3736" href="#3715" class="Bound">as</a><a name="3738" class="Symbol">)</a><a name="3739">
</a></code></pre>
<p>Nothing surprising here, apart from the fact that in the type signature we have to take the trouble of bringing the type variables into scope manually. In Agda, parameters in curly braces are implicit and the type checker will try to infer them by unification. This procedure can fail—term inference is predictably undecidable—in which case the implicits can be explicitly provided, also with curly braces. Here we are also omitting the type of the parameter <code>A</code> by using <code>∀</code>. We can do this since <code>A</code> appears as an argument to <code>List</code> later in the signature. For the converse reason we must provide a type for <code>B</code>.</p>
<h3 id="sums">Sums <a href="#sums" class="section-link">#</a></h3>
<p>Now another “boring” type, <code>Either</code>, plus the associated destructor (<code>either</code> in Haskell):</p>
<pre class="Agda"><code><a name="4479" class="Markup"></a><a name="4491">
</a><a name="4492" class="Keyword">data</a><a name="4496"> </a><a name="4497" href="#4497" class="Datatype">Either</a><a name="4503"> </a><a name="4504" class="Symbol">(</a><a name="4505" href="#4505" class="Bound">A</a><a name="4506"> </a><a name="4507" class="Symbol">:</a><a name="4508"> </a><a name="4509" class="PrimitiveType">Set</a><a name="4512" class="Symbol">)</a><a name="4513"> </a><a name="4514" class="Symbol">(</a><a name="4515" href="#4515" class="Bound">B</a><a name="4516"> </a><a name="4517" class="Symbol">:</a><a name="4518"> </a><a name="4519" class="PrimitiveType">Set</a><a name="4522" class="Symbol">)</a><a name="4523"> </a><a name="4524" class="Symbol">:</a><a name="4525"> </a><a name="4526" class="PrimitiveType">Set</a><a name="4529"> </a><a name="4530" class="Keyword">where</a><a name="4535">
  </a><a name="4538" href="#4538" class="InductiveConstructor">left</a><a name="4542">  </a><a name="4544" class="Symbol">:</a><a name="4545"> </a><a name="4546" href="#4505" class="Bound">A</a><a name="4547"> </a><a name="4548" class="Symbol">→</a><a name="4549"> </a><a name="4550" href="#4497" class="Datatype">Either</a><a name="4556"> </a><a name="4557" href="#4505" class="Bound">A</a><a name="4558"> </a><a name="4559" href="#4515" class="Bound">B</a><a name="4560">
  </a><a name="4563" href="#4563" class="InductiveConstructor">right</a><a name="4568"> </a><a name="4569" class="Symbol">:</a><a name="4570"> </a><a name="4571" href="#4515" class="Bound">B</a><a name="4572"> </a><a name="4573" class="Symbol">→</a><a name="4574"> </a><a name="4575" href="#4497" class="Datatype">Either</a><a name="4581"> </a><a name="4582" href="#4505" class="Bound">A</a><a name="4583"> </a><a name="4584" href="#4515" class="Bound">B</a><a name="4585">

</a><a name="4587" href="#4587" class="Function Operator">[_,_]</a><a name="4592"> </a><a name="4593" class="Symbol">:</a><a name="4594"> </a><a name="4595" class="Symbol">∀</a><a name="4596"> </a><a name="4597" class="Symbol">{</a><a name="4598" href="#4598" class="Bound">A</a><a name="4599"> </a><a name="4600" href="#4600" class="Bound">B</a><a name="4601" class="Symbol">}</a><a name="4602"> </a><a name="4603" class="Symbol">{</a><a name="4604" href="#4604" class="Bound">C</a><a name="4605"> </a><a name="4606" class="Symbol">:</a><a name="4607"> </a><a name="4608" class="PrimitiveType">Set</a><a name="4611" class="Symbol">}</a><a name="4612"> </a><a name="4613" class="Symbol">→</a><a name="4614"> </a><a name="4615" class="Symbol">(</a><a name="4616" href="#4598" class="Bound">A</a><a name="4617"> </a><a name="4618" class="Symbol">→</a><a name="4619"> </a><a name="4620" href="#4604" class="Bound">C</a><a name="4621" class="Symbol">)</a><a name="4622"> </a><a name="4623" class="Symbol">→</a><a name="4624"> </a><a name="4625" class="Symbol">(</a><a name="4626" href="#4600" class="Bound">B</a><a name="4627"> </a><a name="4628" class="Symbol">→</a><a name="4629"> </a><a name="4630" href="#4604" class="Bound">C</a><a name="4631" class="Symbol">)</a><a name="4632"> </a><a name="4633" class="Symbol">→</a><a name="4634"> </a><a name="4635" href="#4497" class="Datatype">Either</a><a name="4641"> </a><a name="4642" href="#4598" class="Bound">A</a><a name="4643"> </a><a name="4644" href="#4600" class="Bound">B</a><a name="4645"> </a><a name="4646" class="Symbol">→</a><a name="4647"> </a><a name="4648" href="#4604" class="Bound">C</a><a name="4649">
</a><a name="4650" href="#4587" class="Function Operator">[</a><a name="4651"> </a><a name="4652" href="#4652" class="Bound">f</a><a name="4653"> </a><a name="4654" href="#4587" class="Function Operator">,</a><a name="4655"> </a><a name="4656" href="#4656" class="Bound">g</a><a name="4657"> </a><a name="4658" href="#4587" class="Function Operator">]</a><a name="4659"> </a><a name="4660" class="Symbol">(</a><a name="4661" href="#4538" class="InductiveConstructor">left</a><a name="4665"> </a><a name="4666" href="#4666" class="Bound">x</a><a name="4667" class="Symbol">)</a><a name="4668">  </a><a name="4670" class="Symbol">=</a><a name="4671"> </a><a name="4672" href="#4652" class="Bound">f</a><a name="4673"> </a><a name="4674" href="#4666" class="Bound">x</a><a name="4675">
</a><a name="4676" href="#4587" class="Function Operator">[</a><a name="4677"> </a><a name="4678" href="#4678" class="Bound">f</a><a name="4679"> </a><a name="4680" href="#4587" class="Function Operator">,</a><a name="4681"> </a><a name="4682" href="#4682" class="Bound">g</a><a name="4683"> </a><a name="4684" href="#4587" class="Function Operator">]</a><a name="4685"> </a><a name="4686" class="Symbol">(</a><a name="4687" href="#4563" class="InductiveConstructor">right</a><a name="4692"> </a><a name="4693" href="#4693" class="Bound">x</a><a name="4694" class="Symbol">)</a><a name="4695"> </a><a name="4696" class="Symbol">=</a><a name="4697"> </a><a name="4698" href="#4682" class="Bound">g</a><a name="4699"> </a><a name="4700" href="#4693" class="Bound">x</a><a name="4701">
</a></code></pre>
<h3 id="unhabited-types">Unhabited types <a href="#unhabited-types" class="section-link">#</a></h3>
<p>Now for a type with no inhabitants—no constructors:</p>
<pre class="Agda"><code><a name="4790" class="Markup"></a><a name="4802">
</a><a name="4803" class="Keyword">data</a><a name="4807"> </a><a name="4808" href="#4808" class="Datatype">Empty</a><a name="4813"> </a><a name="4814" class="Symbol">:</a><a name="4815"> </a><a name="4816" class="PrimitiveType">Set</a><a name="4819"> </a><a name="4820" class="Keyword">where</a><a name="4825">
</a></code></pre>
<p>What is <code>Empty</code> useful for? Well, if the user provides a term of type <code>Empty</code>, we can give back anything he might want, corresponding to the logical <em>ex falso quodlibet</em>:</p>
<pre class="Agda"><code><a name="5011" class="Markup"></a><a name="5023">
</a><a name="5024" href="#5024" class="Function">absurd</a><a name="5030"> </a><a name="5031" class="Symbol">:</a><a name="5032"> </a><a name="5033" class="Symbol">{</a><a name="5034" href="#5034" class="Bound">X</a><a name="5035"> </a><a name="5036" class="Symbol">:</a><a name="5037"> </a><a name="5038" class="PrimitiveType">Set</a><a name="5041" class="Symbol">}</a><a name="5042"> </a><a name="5043" class="Symbol">→</a><a name="5044"> </a><a name="5045" href="#4808" class="Datatype">Empty</a><a name="5050"> </a><a name="5051" class="Symbol">→</a><a name="5052"> </a><a name="5053" href="#5034" class="Bound">X</a><a name="5054">
</a><a name="5055" href="#5024" class="Function">absurd</a><a name="5061"> </a><a name="5062" class="Symbol">()</a><a name="5064">
</a></code></pre>
<p>The <code>()</code> is what is called an <em>empty pattern</em>: Agda knows that no closed term will be of type <code>Empty</code>, and thus lets us leave out the body of functions with arguments of that type. Note that in Haskell we can easily get terms of <em>any</em> type in various ways, the most straightforward being general recursion:</p>
<pre><code>undefined :: forall a. a
undefined = undefined</code></pre>
<p>Agda makes sure that this is not possible,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> thus keeping the system <em>consistent</em>. This has very pleasant consequences, the most prominent being that all programs terminate. For this reason consistent systems must be Turing-incomplete (we can’t write an infinite loops!), and thus Agda lets us step out of these checks if we want to, although it is rarely needed—most algorithms we write are quite easily provably terminating. Note that consistency wasn’t put in Agda only to please mathematicians: given the expressivity of the type system type checking and evaluation are tightly intertwined, and thus we can send the compiler in an infinite loop if we can write one.</p>
<p>We use <code>Empty</code> to define something close to negation in logic:</p>
<pre class="Agda"><code><a name="6536" class="Markup"></a><a name="6548">
</a><a name="6549" class="Keyword">infix</a><a name="6554"> </a><a name="6555" class="Number">3</a><a name="6556"> </a><a name="6557" href="#6560" class="Function Operator">¬_</a><a name="6559">
</a><a name="6560" href="#6560" class="Function Operator">¬_</a><a name="6562"> </a><a name="6563" class="Symbol">:</a><a name="6564"> </a><a name="6565" class="PrimitiveType">Set</a><a name="6568"> </a><a name="6569" class="Symbol">→</a><a name="6570"> </a><a name="6571" class="PrimitiveType">Set</a><a name="6574">
</a><a name="6575" href="#6560" class="Function Operator">¬</a><a name="6576"> </a><a name="6577" href="#6577" class="Bound">X</a><a name="6578"> </a><a name="6579" class="Symbol">=</a><a name="6580"> </a><a name="6581" href="#6577" class="Bound">X</a><a name="6582"> </a><a name="6583" class="Symbol">→</a><a name="6584"> </a><a name="6585" href="#4808" class="Datatype">Empty</a><a name="6590">
</a></code></pre>
<p>For example we would expect terms of type <code>¬ (3 &gt; 4)</code> to exist. Here it starts being clear that types are very first class in Agda; functions can work on them as they do with ordinary values: in this case <code>¬</code> takes a type and forms another one.</p>
<h2 id="different-relations">Different <code>Rel</code>ations <a href="#different-relations" class="section-link">#</a></h2>
<p>We need one last ingredient before we can start sorting. We <em>could</em> write our sort for some specific data type, say integers, but why would we do that considering that we have a language that lets us express abstract structures very naturally?</p>
<p>Instead, we can give a general definition for a binary relation on a type <code>X</code>:</p>
<pre class="Agda"><code><a name="7202" class="Markup"></a><a name="7214">
</a><a name="7215" href="#7215" class="Function">Rel</a><a name="7218"> </a><a name="7219" class="Symbol">:</a><a name="7220"> </a><a name="7221" class="PrimitiveType">Set</a><a name="7224"> </a><a name="7225" class="Symbol">→</a><a name="7226"> </a><a name="7227" class="PrimitiveType">Set₁</a><a name="7231">
</a><a name="7232" href="#7215" class="Function">Rel</a><a name="7235"> </a><a name="7236" href="#7236" class="Bound">X</a><a name="7237"> </a><a name="7238" class="Symbol">=</a><a name="7239"> </a><a name="7240" href="#7236" class="Bound">X</a><a name="7241"> </a><a name="7242" class="Symbol">→</a><a name="7243"> </a><a name="7244" href="#7236" class="Bound">X</a><a name="7245"> </a><a name="7246" class="Symbol">→</a><a name="7247"> </a><a name="7248" class="PrimitiveType">Set</a><a name="7251">
</a></code></pre>
<p>The <code>Set₁</code> indicates that a relation between two <code>Set</code>s is “larger” than a <code>Set</code> itself—this is nothing to worry about now, but it follows a tradition in set theory that goes back to Russell to avoid paradoxes.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> <code>Set</code> is in fact a shorthand for <code>Set₀</code> and represents the type of types of values: <code>Empty : Set₀ : Set₁ : Set₂ : ...</code>.</p>
<p>Then we define the type of decidable relations—we would expect relations like “less than” on natural numbers or “sortedness” on lists to be decidable:</p>
<pre class="Agda"><code><a name="7948" class="Markup"></a><a name="7960">
</a><a name="7961" href="#7961" class="Function">Decidable</a><a name="7970"> </a><a name="7971" class="Symbol">:</a><a name="7972"> </a><a name="7973" class="Symbol">∀</a><a name="7974"> </a><a name="7975" class="Symbol">{</a><a name="7976" href="#7976" class="Bound">X</a><a name="7977" class="Symbol">}</a><a name="7978"> </a><a name="7979" class="Symbol">→</a><a name="7980"> </a><a name="7981" href="#7215" class="Function">Rel</a><a name="7984"> </a><a name="7985" href="#7976" class="Bound">X</a><a name="7986"> </a><a name="7987" class="Symbol">→</a><a name="7988"> </a><a name="7989" class="PrimitiveType">Set</a><a name="7992">
</a><a name="7993" href="#7961" class="Function">Decidable</a><a name="8002"> </a><a name="8003" href="#8003" class="Bound">R</a><a name="8004"> </a><a name="8005" class="Symbol">=</a><a name="8006"> </a><a name="8007" class="Symbol">∀</a><a name="8008"> </a><a name="8009" href="#8009" class="Bound">x</a><a name="8010"> </a><a name="8011" href="#8011" class="Bound">y</a><a name="8012"> </a><a name="8013" class="Symbol">→</a><a name="8014"> </a><a name="8015" href="#4497" class="Datatype">Either</a><a name="8021"> </a><a name="8022" class="Symbol">(</a><a name="8023" href="#8003" class="Bound">R</a><a name="8024"> </a><a name="8025" href="#8009" class="Bound">x</a><a name="8026"> </a><a name="8027" href="#8011" class="Bound">y</a><a name="8028" class="Symbol">)</a><a name="8029"> </a><a name="8030" class="Symbol">(</a><a name="8031" href="#6560" class="Function Operator">¬</a><a name="8032"> </a><a name="8033" class="Symbol">(</a><a name="8034" href="#8003" class="Bound">R</a><a name="8035"> </a><a name="8036" href="#8009" class="Bound">x</a><a name="8037"> </a><a name="8038" href="#8011" class="Bound">y</a><a name="8039" class="Symbol">))</a><a name="8041">
</a></code></pre>
<p>That is, a decidable relation has a function that tells us if any <code>x</code> and <code>y</code> are related or not.</p>
<p>Now the interesting part. To sort a list, we need two relations on the elements of the list: some notion of equality and some ordering on the elements (in fact the latter requires the former). More formally, the equality will be an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>. To express abstract properties over types we can use a record, much like type classes are used in Haskell—only more flexible but without the big advantage of having automatic instance resolution:</p>
<pre class="Agda"><code><a name="8663" class="Markup"></a><a name="8675">
</a><a name="8676" class="Keyword">record</a><a name="8682"> </a><a name="8683" href="#8683" class="Record">Equivalence</a><a name="8694"> </a><a name="8695" class="Symbol">{</a><a name="8696" href="#8696" class="Bound">X</a><a name="8697" class="Symbol">}</a><a name="8698"> </a><a name="8699" class="Symbol">(</a><a name="8700" href="#8700" class="Bound Operator">_≈_</a><a name="8703"> </a><a name="8704" class="Symbol">:</a><a name="8705"> </a><a name="8706" href="#7215" class="Function">Rel</a><a name="8709"> </a><a name="8710" href="#8696" class="Bound">X</a><a name="8711" class="Symbol">)</a><a name="8712"> </a><a name="8713" class="Symbol">:</a><a name="8714"> </a><a name="8715" class="PrimitiveType">Set₁</a><a name="8719"> </a><a name="8720" class="Keyword">where</a><a name="8725">
  </a><a name="8728" class="Keyword">field</a><a name="8733">
    </a><a name="8738" href="#8738" class="Field">refl</a><a name="8742">  </a><a name="8744" class="Symbol">:</a><a name="8745"> </a><a name="8746" class="Symbol">∀</a><a name="8747"> </a><a name="8748" class="Symbol">{</a><a name="8749" href="#8749" class="Bound">x</a><a name="8750" class="Symbol">}</a><a name="8751">     </a><a name="8756" class="Symbol">→</a><a name="8757"> </a><a name="8758" href="#8749" class="Bound">x</a><a name="8759"> </a><a name="8760" href="#8700" class="Bound Operator">≈</a><a name="8761"> </a><a name="8762" href="#8749" class="Bound">x</a><a name="8763">
    </a><a name="8768" href="#8768" class="Field">sym</a><a name="8771">   </a><a name="8774" class="Symbol">:</a><a name="8775"> </a><a name="8776" class="Symbol">∀</a><a name="8777"> </a><a name="8778" class="Symbol">{</a><a name="8779" href="#8779" class="Bound">x</a><a name="8780"> </a><a name="8781" href="#8781" class="Bound">y</a><a name="8782" class="Symbol">}</a><a name="8783">   </a><a name="8786" class="Symbol">→</a><a name="8787"> </a><a name="8788" href="#8779" class="Bound">x</a><a name="8789"> </a><a name="8790" href="#8700" class="Bound Operator">≈</a><a name="8791"> </a><a name="8792" href="#8781" class="Bound">y</a><a name="8793"> </a><a name="8794" class="Symbol">→</a><a name="8795"> </a><a name="8796" href="#8781" class="Bound">y</a><a name="8797"> </a><a name="8798" href="#8700" class="Bound Operator">≈</a><a name="8799"> </a><a name="8800" href="#8779" class="Bound">x</a><a name="8801">
    </a><a name="8806" href="#8806" class="Field">trans</a><a name="8811"> </a><a name="8812" class="Symbol">:</a><a name="8813"> </a><a name="8814" class="Symbol">∀</a><a name="8815"> </a><a name="8816" class="Symbol">{</a><a name="8817" href="#8817" class="Bound">x</a><a name="8818"> </a><a name="8819" href="#8819" class="Bound">y</a><a name="8820"> </a><a name="8821" href="#8821" class="Bound">z</a><a name="8822" class="Symbol">}</a><a name="8823"> </a><a name="8824" class="Symbol">→</a><a name="8825"> </a><a name="8826" href="#8817" class="Bound">x</a><a name="8827"> </a><a name="8828" href="#8700" class="Bound Operator">≈</a><a name="8829"> </a><a name="8830" href="#8819" class="Bound">y</a><a name="8831"> </a><a name="8832" class="Symbol">→</a><a name="8833"> </a><a name="8834" href="#8819" class="Bound">y</a><a name="8835"> </a><a name="8836" href="#8700" class="Bound Operator">≈</a><a name="8837"> </a><a name="8838" href="#8821" class="Bound">z</a><a name="8839"> </a><a name="8840" class="Symbol">→</a><a name="8841"> </a><a name="8842" href="#8817" class="Bound">x</a><a name="8843"> </a><a name="8844" href="#8700" class="Bound Operator">≈</a><a name="8845"> </a><a name="8846" href="#8821" class="Bound">z</a><a name="8847">
</a></code></pre>
<p>The definition on Wikipedia translates literally to Agda. Same story for our ordering, which will need to be <a href="https://en.wikipedia.org/wiki/Total_ordering">total</a>:</p>
<pre class="Agda"><code><a name="9026" class="Markup"></a><a name="9038">
</a><a name="9039" class="Keyword">record</a><a name="9045"> </a><a name="9046" href="#9046" class="Record">TotalOrder</a><a name="9056"> </a><a name="9057" class="Symbol">{</a><a name="9058" href="#9058" class="Bound">X</a><a name="9059" class="Symbol">}</a><a name="9060"> </a><a name="9061" class="Symbol">(</a><a name="9062" href="#9062" class="Bound Operator">_≈_</a><a name="9065"> </a><a name="9066" class="Symbol">:</a><a name="9067"> </a><a name="9068" href="#7215" class="Function">Rel</a><a name="9071"> </a><a name="9072" href="#9058" class="Bound">X</a><a name="9073" class="Symbol">)</a><a name="9074"> </a><a name="9075" class="Symbol">(</a><a name="9076" href="#9076" class="Bound Operator">_≤_</a><a name="9079"> </a><a name="9080" class="Symbol">:</a><a name="9081"> </a><a name="9082" href="#7215" class="Function">Rel</a><a name="9085"> </a><a name="9086" href="#9058" class="Bound">X</a><a name="9087" class="Symbol">)</a><a name="9088"> </a><a name="9089" class="Symbol">:</a><a name="9090"> </a><a name="9091" class="PrimitiveType">Set₁</a><a name="9095"> </a><a name="9096" class="Keyword">where</a><a name="9101">
  </a><a name="9104" class="Keyword">field</a><a name="9109">
    </a><a name="9114" href="#9114" class="Field">antisym</a><a name="9121">     </a><a name="9126" class="Symbol">:</a><a name="9127"> </a><a name="9128" class="Symbol">∀</a><a name="9129"> </a><a name="9130" class="Symbol">{</a><a name="9131" href="#9131" class="Bound">x</a><a name="9132"> </a><a name="9133" href="#9133" class="Bound">y</a><a name="9134" class="Symbol">}</a><a name="9135">   </a><a name="9138" class="Symbol">→</a><a name="9139"> </a><a name="9140" href="#9131" class="Bound">x</a><a name="9141"> </a><a name="9142" href="#9076" class="Bound Operator">≤</a><a name="9143"> </a><a name="9144" href="#9133" class="Bound">y</a><a name="9145"> </a><a name="9146" class="Symbol">→</a><a name="9147"> </a><a name="9148" href="#9133" class="Bound">y</a><a name="9149"> </a><a name="9150" href="#9076" class="Bound Operator">≤</a><a name="9151"> </a><a name="9152" href="#9131" class="Bound">x</a><a name="9153"> </a><a name="9154" class="Symbol">→</a><a name="9155"> </a><a name="9156" href="#9131" class="Bound">x</a><a name="9157"> </a><a name="9158" href="#9062" class="Bound Operator">≈</a><a name="9159"> </a><a name="9160" href="#9133" class="Bound">y</a><a name="9161">
    </a><a name="9166" href="#9166" class="Field">trans</a><a name="9171">       </a><a name="9178" class="Symbol">:</a><a name="9179"> </a><a name="9180" class="Symbol">∀</a><a name="9181"> </a><a name="9182" class="Symbol">{</a><a name="9183" href="#9183" class="Bound">x</a><a name="9184"> </a><a name="9185" href="#9185" class="Bound">y</a><a name="9186"> </a><a name="9187" href="#9187" class="Bound">z</a><a name="9188" class="Symbol">}</a><a name="9189"> </a><a name="9190" class="Symbol">→</a><a name="9191"> </a><a name="9192" href="#9183" class="Bound">x</a><a name="9193"> </a><a name="9194" href="#9076" class="Bound Operator">≤</a><a name="9195"> </a><a name="9196" href="#9185" class="Bound">y</a><a name="9197"> </a><a name="9198" class="Symbol">→</a><a name="9199"> </a><a name="9200" href="#9185" class="Bound">y</a><a name="9201"> </a><a name="9202" href="#9076" class="Bound Operator">≤</a><a name="9203"> </a><a name="9204" href="#9187" class="Bound">z</a><a name="9205"> </a><a name="9206" class="Symbol">→</a><a name="9207"> </a><a name="9208" href="#9183" class="Bound">x</a><a name="9209"> </a><a name="9210" href="#9076" class="Bound Operator">≤</a><a name="9211"> </a><a name="9212" href="#9187" class="Bound">z</a><a name="9213">
    </a><a name="9218" href="#9218" class="Field">total</a><a name="9223">       </a><a name="9230" class="Symbol">:</a><a name="9231"> </a><a name="9232" class="Symbol">∀</a><a name="9233"> </a><a name="9234" href="#9234" class="Bound">x</a><a name="9235"> </a><a name="9236" href="#9236" class="Bound">y</a><a name="9237">     </a><a name="9242" class="Symbol">→</a><a name="9243"> </a><a name="9244" href="#4497" class="Datatype">Either</a><a name="9250"> </a><a name="9251" class="Symbol">(</a><a name="9252" href="#9234" class="Bound">x</a><a name="9253"> </a><a name="9254" href="#9076" class="Bound Operator">≤</a><a name="9255"> </a><a name="9256" href="#9236" class="Bound">y</a><a name="9257" class="Symbol">)</a><a name="9258"> </a><a name="9259" class="Symbol">(</a><a name="9260" href="#9236" class="Bound">y</a><a name="9261"> </a><a name="9262" href="#9076" class="Bound Operator">≤</a><a name="9263"> </a><a name="9264" href="#9234" class="Bound">x</a><a name="9265" class="Symbol">)</a><a name="9266">
    </a><a name="9271" href="#9271" class="Field">reflexive</a><a name="9280">   </a><a name="9283" class="Symbol">:</a><a name="9284"> </a><a name="9285" class="Symbol">∀</a><a name="9286"> </a><a name="9287" class="Symbol">{</a><a name="9288" href="#9288" class="Bound">x</a><a name="9289"> </a><a name="9290" href="#9290" class="Bound">y</a><a name="9291" class="Symbol">}</a><a name="9292">   </a><a name="9295" class="Symbol">→</a><a name="9296"> </a><a name="9297" href="#9288" class="Bound">x</a><a name="9298"> </a><a name="9299" href="#9062" class="Bound Operator">≈</a><a name="9300"> </a><a name="9301" href="#9290" class="Bound">y</a><a name="9302"> </a><a name="9303" class="Symbol">→</a><a name="9304"> </a><a name="9305" href="#9288" class="Bound">x</a><a name="9306"> </a><a name="9307" href="#9076" class="Bound Operator">≤</a><a name="9308"> </a><a name="9309" href="#9290" class="Bound">y</a><a name="9310">
    </a><a name="9315" href="#9315" class="Field">equivalence</a><a name="9326"> </a><a name="9327" class="Symbol">:</a><a name="9328"> </a><a name="9329" href="#8683" class="Record">Equivalence</a><a name="9340"> </a><a name="9341" href="#9062" class="Bound Operator">_≈_</a><a name="9344">
</a></code></pre>
<h2 id="sorting">Sorting <a href="#sorting" class="section-link">#</a></h2>
<p>We can finally begin to sort. To do this we will define a module parametrised over a type and an ordering. Agda has a very flexible module system—in fact we have already been using it by defining records, which are implicitly modules.</p>
<pre class="Agda"><code><a name="9609" class="Markup"></a><a name="9621">
</a><a name="9622" class="Keyword">module</a><a name="9628"> </a><a name="9629" href="#9629" class="Module">Sort</a><a name="9633"> </a><a name="9634" class="Symbol">{</a><a name="9635" href="#9635" class="Bound">X</a><a name="9636" class="Symbol">}</a><a name="9637"> </a><a name="9638" class="Symbol">{</a><a name="9639" href="#9639" class="Bound Operator">_≈_</a><a name="9642"> </a><a name="9643" href="#9643" class="Bound Operator">_≤_</a><a name="9646"> </a><a name="9647" class="Symbol">:</a><a name="9648"> </a><a name="9649" href="#7215" class="Function">Rel</a><a name="9652"> </a><a name="9653" href="#9635" class="Bound">X</a><a name="9654" class="Symbol">}</a><a name="9655">
            </a><a name="9668" class="Symbol">(</a><a name="9669" href="#9669" class="Bound Operator">_≤?_</a><a name="9673"> </a><a name="9674" class="Symbol">:</a><a name="9675"> </a><a name="9676" href="#7961" class="Function">Decidable</a><a name="9685"> </a><a name="9686" href="#9643" class="Bound Operator">_≤_</a><a name="9689" class="Symbol">)</a><a name="9690"> </a><a name="9691" class="Symbol">(</a><a name="9692" href="#9692" class="Bound">ord</a><a name="9695"> </a><a name="9696" class="Symbol">:</a><a name="9697"> </a><a name="9698" href="#9046" class="Record">TotalOrder</a><a name="9708"> </a><a name="9709" href="#9639" class="Bound Operator">_≈_</a><a name="9712"> </a><a name="9713" href="#9643" class="Bound Operator">_≤_</a><a name="9716" class="Symbol">)</a><a name="9717"> </a><a name="9718" class="Keyword">where</a><a name="9723">
  </a><a name="9726" class="Keyword">open</a><a name="9730"> </a><a name="9731" href="#9046" class="Module">TotalOrder</a><a name="9741"> </a><a name="9742" href="#9692" class="Bound">ord</a><a name="9745"> </a><a name="9746" class="Keyword">using</a><a name="9751"> </a><a name="9752" class="Symbol">(</a><a name="9753">total</a><a name="9758" class="Symbol">;</a><a name="9759"> equivalence</a><a name="9771" class="Symbol">)</a><a name="9772">
  </a><a name="9775" class="Keyword">open</a><a name="9779"> </a><a name="9780" href="#8683" class="Module">Equivalence</a><a name="9791"> </a><a name="9792" href="#9315" class="Field">equivalence</a><a name="9803"> </a><a name="9804" class="Keyword">using</a><a name="9809"> </a><a name="9810" class="Symbol">(</a><a name="9811">refl</a><a name="9815" class="Symbol">)</a><a name="9816">
</a></code></pre>
<p>We require the ordering relation to be decidable, and we bring in scope some fields of the records using <code>open</code>, so that we can use them directly.</p>
<h3 id="insertion-sort">Insertion sort <a href="#insertion-sort" class="section-link">#</a></h3>
<p>We want to represent bounded lists, but we also want the bounds to be possibly open. For this purpose we lift our type <code>X</code> in a data type that contains a top and bottom elements, that are respectively greater or equal and lower or equal than all the other elements.</p>
<pre class="Agda"><code><a name="10265" class="Markup"></a><a name="10277">
  </a><a name="10280" class="Keyword">data</a><a name="10284"> </a><a name="10285" href="#10285" class="Datatype">⊥X⊤</a><a name="10288"> </a><a name="10289" class="Symbol">:</a><a name="10290"> </a><a name="10291" class="PrimitiveType">Set</a><a name="10294"> </a><a name="10295" class="Keyword">where</a><a name="10300">
    </a><a name="10305" href="#10305" class="InductiveConstructor">⊤</a><a name="10306"> </a><a name="10307" href="#10307" class="InductiveConstructor">⊥</a><a name="10308"> </a><a name="10309" class="Symbol">:</a><a name="10310"> </a><a name="10311" href="#10285" class="Datatype">⊥X⊤</a><a name="10314">
    </a><a name="10319" href="#10319" class="InductiveConstructor Operator">⟦_⟧</a><a name="10322"> </a><a name="10323" class="Symbol">:</a><a name="10324"> </a><a name="10325" href="#9635" class="Bound">X</a><a name="10326"> </a><a name="10327" class="Symbol">→</a><a name="10328"> </a><a name="10329" href="#10285" class="Datatype">⊥X⊤</a><a name="10332">
</a></code></pre>
<p>For <code>⊥X⊤</code> to be useful, we lift our ordering to work with it, following our considerations about the top and bottom elements:</p>
<pre class="Agda"><code><a name="10472" class="Markup"></a><a name="10484">
  </a><a name="10487" class="Keyword">data</a><a name="10491"> </a><a name="10492" href="#10492" class="Datatype Operator">_≤̂_</a><a name="10496"> </a><a name="10497" class="Symbol">:</a><a name="10498"> </a><a name="10499" href="#7215" class="Function">Rel</a><a name="10502"> </a><a name="10503" href="#10285" class="Datatype">⊥X⊤</a><a name="10506"> </a><a name="10507" class="Keyword">where</a><a name="10512">
    </a><a name="10517" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="10520">     </a><a name="10525" class="Symbol">:</a><a name="10526"> </a><a name="10527" class="Symbol">∀</a><a name="10528"> </a><a name="10529" class="Symbol">{</a><a name="10530" href="#10530" class="Bound">x</a><a name="10531" class="Symbol">}</a><a name="10532"> </a><a name="10533" class="Symbol">→</a><a name="10534"> </a><a name="10535" href="#10307" class="InductiveConstructor">⊥</a><a name="10536"> </a><a name="10537" href="#10492" class="Datatype Operator">≤̂</a><a name="10539"> </a><a name="10540" href="#10530" class="Bound">x</a><a name="10541">
    </a><a name="10546" href="#10546" class="InductiveConstructor">≤̂⊤</a><a name="10549">     </a><a name="10554" class="Symbol">:</a><a name="10555"> </a><a name="10556" class="Symbol">∀</a><a name="10557"> </a><a name="10558" class="Symbol">{</a><a name="10559" href="#10559" class="Bound">x</a><a name="10560" class="Symbol">}</a><a name="10561"> </a><a name="10562" class="Symbol">→</a><a name="10563"> </a><a name="10564" href="#10559" class="Bound">x</a><a name="10565"> </a><a name="10566" href="#10492" class="Datatype Operator">≤̂</a><a name="10568"> </a><a name="10569" href="#10305" class="InductiveConstructor">⊤</a><a name="10570">
    </a><a name="10575" href="#10575" class="InductiveConstructor">≤-lift</a><a name="10581"> </a><a name="10582" class="Symbol">:</a><a name="10583"> </a><a name="10584" class="Symbol">∀</a><a name="10585"> </a><a name="10586" class="Symbol">{</a><a name="10587" href="#10587" class="Bound">x</a><a name="10588"> </a><a name="10589" href="#10589" class="Bound">y</a><a name="10590" class="Symbol">}</a><a name="10591"> </a><a name="10592" class="Symbol">→</a><a name="10593"> </a><a name="10594" href="#10587" class="Bound">x</a><a name="10595"> </a><a name="10596" href="#9643" class="Bound Operator">≤</a><a name="10597"> </a><a name="10598" href="#10589" class="Bound">y</a><a name="10599"> </a><a name="10600" class="Symbol">→</a><a name="10601"> </a><a name="10602" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="10603"> </a><a name="10604" href="#10587" class="Bound">x</a><a name="10605"> </a><a name="10606" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="10607"> </a><a name="10608" href="#10492" class="Datatype Operator">≤̂</a><a name="10610"> </a><a name="10611" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="10612"> </a><a name="10613" href="#10589" class="Bound">y</a><a name="10614"> </a><a name="10615" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="10616">
</a></code></pre>
<p>Note that this data type is different from what we have defined before: the parameters to the type constructor can vary between data constructors—much like in GADTs in Haskell. In Agda, “changing” (more formally “non linear”) parameters are known as <em>indices</em>, as opposed to non-changing <em>parameters</em>. Parameters are named and to the left of the colon, while the type to the right of the colon will determine the number and type of indices—in this case two <code>⊥X⊤</code>s (remember, <code>Rel ⊥X⊤ = ⊥X⊤ → ⊥X⊤ → Set</code>). This kind of data type is known as <em>inductive family</em>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>We can now define the type of bounded, ordered lists:</p>
<pre class="Agda"><code><a name="11581" class="Markup"></a><a name="11593">
  </a><a name="11596" class="Keyword">data</a><a name="11600"> </a><a name="11601" href="#11601" class="Datatype">OList</a><a name="11606"> </a><a name="11607" class="Symbol">(</a><a name="11608" href="#11608" class="Bound">l</a><a name="11609"> </a><a name="11610" href="#11610" class="Bound">u</a><a name="11611"> </a><a name="11612" class="Symbol">:</a><a name="11613"> </a><a name="11614" href="#10285" class="Datatype">⊥X⊤</a><a name="11617" class="Symbol">)</a><a name="11618"> </a><a name="11619" class="Symbol">:</a><a name="11620"> </a><a name="11621" class="PrimitiveType">Set</a><a name="11624"> </a><a name="11625" class="Keyword">where</a><a name="11630">
    </a><a name="11635" href="#11635" class="InductiveConstructor">nil</a><a name="11638">  </a><a name="11640" class="Symbol">:</a><a name="11641"> </a><a name="11642" href="#11608" class="Bound">l</a><a name="11643"> </a><a name="11644" href="#10492" class="Datatype Operator">≤̂</a><a name="11646"> </a><a name="11647" href="#11610" class="Bound">u</a><a name="11648"> </a><a name="11649" class="Symbol">→</a><a name="11650"> </a><a name="11651" href="#11601" class="Datatype">OList</a><a name="11656"> </a><a name="11657" href="#11608" class="Bound">l</a><a name="11658"> </a><a name="11659" href="#11610" class="Bound">u</a><a name="11660">
    </a><a name="11665" href="#11665" class="InductiveConstructor">cons</a><a name="11669"> </a><a name="11670" class="Symbol">:</a><a name="11671"> </a><a name="11672" class="Symbol">∀</a><a name="11673"> </a><a name="11674" href="#11674" class="Bound">x</a><a name="11675"> </a><a name="11676" class="Symbol">(</a><a name="11677" href="#11677" class="Bound">xs</a><a name="11679"> </a><a name="11680" class="Symbol">:</a><a name="11681"> </a><a name="11682" href="#11601" class="Datatype">OList</a><a name="11687"> </a><a name="11688" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="11689"> </a><a name="11690" href="#11674" class="Bound">x</a><a name="11691"> </a><a name="11692" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="11693"> </a><a name="11694" href="#11610" class="Bound">u</a><a name="11695" class="Symbol">)</a><a name="11696"> </a><a name="11697" class="Symbol">→</a><a name="11698"> </a><a name="11699" href="#11608" class="Bound">l</a><a name="11700"> </a><a name="11701" href="#10492" class="Datatype Operator">≤̂</a><a name="11703"> </a><a name="11704" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="11705"> </a><a name="11706" href="#11674" class="Bound">x</a><a name="11707"> </a><a name="11708" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="11709"> </a><a name="11710" class="Symbol">→</a><a name="11711"> </a><a name="11712" href="#11601" class="Datatype">OList</a><a name="11717"> </a><a name="11718" href="#11608" class="Bound">l</a><a name="11719"> </a><a name="11720" href="#11610" class="Bound">u</a><a name="11721">
</a></code></pre>
<p><code>nil</code> will work with any bounds, provided that the lower <code>l</code> is less or equal than the upper <code>u</code>. <code>cons</code> will cons an element <code>x</code> to a list with <code>x</code> as a lower bound, and return a list with lower bound <code>l</code>, provided that <code>l ≤̂ ⟦ x ⟧</code>. It’s clear from how <code>cons</code> work that the elements in <code>OList</code> will be ordered according to the <code>≤</code> relation.</p>
<p>We can easily get a plain list back from an <code>OList</code>:</p>
<pre class="Agda"><code><a name="12133" class="Markup"></a><a name="12145">
  </a><a name="12148" href="#12148" class="Function">toList</a><a name="12154"> </a><a name="12155" class="Symbol">:</a><a name="12156"> </a><a name="12157" class="Symbol">∀</a><a name="12158"> </a><a name="12159" class="Symbol">{</a><a name="12160" href="#12160" class="Bound">l</a><a name="12161"> </a><a name="12162" href="#12162" class="Bound">u</a><a name="12163" class="Symbol">}</a><a name="12164"> </a><a name="12165" class="Symbol">→</a><a name="12166"> </a><a name="12167" href="#11601" class="Datatype">OList</a><a name="12172"> </a><a name="12173" href="#12160" class="Bound">l</a><a name="12174"> </a><a name="12175" href="#12162" class="Bound">u</a><a name="12176"> </a><a name="12177" class="Symbol">→</a><a name="12178"> </a><a name="12179" href="#2675" class="Datatype">List</a><a name="12183"> </a><a name="12184" href="#9635" class="Bound">X</a><a name="12185">
  </a><a name="12188" href="#12148" class="Function">toList</a><a name="12194"> </a><a name="12195" class="Symbol">(</a><a name="12196" href="#11635" class="InductiveConstructor">nil</a><a name="12199"> </a><a name="12200" class="Symbol">_)</a><a name="12202">       </a><a name="12209" class="Symbol">=</a><a name="12210"> </a><a name="12211" href="#2704" class="InductiveConstructor">[]</a><a name="12213">
  </a><a name="12216" href="#12148" class="Function">toList</a><a name="12222"> </a><a name="12223" class="Symbol">(</a><a name="12224" href="#11665" class="InductiveConstructor">cons</a><a name="12228"> </a><a name="12229" href="#12229" class="Bound">x</a><a name="12230"> </a><a name="12231" href="#12231" class="Bound">xs</a><a name="12233"> </a><a name="12234" class="Symbol">_)</a><a name="12236"> </a><a name="12237" class="Symbol">=</a><a name="12238"> </a><a name="12239" href="#12229" class="Bound">x</a><a name="12240"> </a><a name="12241" href="#2719" class="InductiveConstructor Operator">∷</a><a name="12242"> </a><a name="12243" href="#12148" class="Function">toList</a><a name="12249"> </a><a name="12250" href="#12231" class="Bound">xs</a><a name="12252">
</a></code></pre>
<p>With the right data types, writing and proving correct<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> an <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a> is a breeze—I encourage you to try and writing yourself checking the goals as you pattern match, the only non-trivial case being the last one:</p>
<pre class="Agda"><code><a name="12809" class="Markup"></a><a name="12821">
  </a><a name="12824" href="#12824" class="Function">insert</a><a name="12830"> </a><a name="12831" class="Symbol">:</a><a name="12832"> </a><a name="12833" class="Symbol">∀</a><a name="12834"> </a><a name="12835" class="Symbol">{</a><a name="12836" href="#12836" class="Bound">l</a><a name="12837"> </a><a name="12838" href="#12838" class="Bound">u</a><a name="12839" class="Symbol">}</a><a name="12840"> </a><a name="12841" href="#12841" class="Bound">x</a><a name="12842"> </a><a name="12843" class="Symbol">→</a><a name="12844"> </a><a name="12845" href="#11601" class="Datatype">OList</a><a name="12850"> </a><a name="12851" href="#12836" class="Bound">l</a><a name="12852"> </a><a name="12853" href="#12838" class="Bound">u</a><a name="12854"> </a><a name="12855" class="Symbol">→</a><a name="12856"> </a><a name="12857" href="#12836" class="Bound">l</a><a name="12858"> </a><a name="12859" href="#10492" class="Datatype Operator">≤̂</a><a name="12861"> </a><a name="12862" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="12863"> </a><a name="12864" href="#12841" class="Bound">x</a><a name="12865"> </a><a name="12866" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="12867"> </a><a name="12868" class="Symbol">→</a><a name="12869"> </a><a name="12870" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="12871"> </a><a name="12872" href="#12841" class="Bound">x</a><a name="12873"> </a><a name="12874" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="12875"> </a><a name="12876" href="#10492" class="Datatype Operator">≤̂</a><a name="12878"> </a><a name="12879" href="#12838" class="Bound">u</a><a name="12880"> </a><a name="12881" class="Symbol">→</a><a name="12882"> </a><a name="12883" href="#11601" class="Datatype">OList</a><a name="12888"> </a><a name="12889" href="#12836" class="Bound">l</a><a name="12890"> </a><a name="12891" href="#12838" class="Bound">u</a><a name="12892">
  </a><a name="12895" href="#12824" class="Function">insert</a><a name="12901"> </a><a name="12902" href="#12902" class="Bound">y</a><a name="12903"> </a><a name="12904" class="Symbol">(</a><a name="12905" href="#11635" class="InductiveConstructor">nil</a><a name="12908"> </a><a name="12909" class="Symbol">_)</a><a name="12911">         </a><a name="12920" href="#12920" class="Bound">l≤y</a><a name="12923"> </a><a name="12924" href="#12924" class="Bound">y≤u</a><a name="12927"> </a><a name="12928" class="Symbol">=</a><a name="12929"> </a><a name="12930" href="#11665" class="InductiveConstructor">cons</a><a name="12934"> </a><a name="12935" href="#12902" class="Bound">y</a><a name="12936"> </a><a name="12937" class="Symbol">(</a><a name="12938" href="#11635" class="InductiveConstructor">nil</a><a name="12941"> </a><a name="12942" href="#12924" class="Bound">y≤u</a><a name="12945" class="Symbol">)</a><a name="12946"> </a><a name="12947" href="#12920" class="Bound">l≤y</a><a name="12950">
  </a><a name="12953" href="#12824" class="Function">insert</a><a name="12959"> </a><a name="12960" href="#12960" class="Bound">y</a><a name="12961"> </a><a name="12962" class="Symbol">(</a><a name="12963" href="#11665" class="InductiveConstructor">cons</a><a name="12967"> </a><a name="12968" href="#12968" class="Bound">x</a><a name="12969"> </a><a name="12970" href="#12970" class="Bound">xs</a><a name="12972"> </a><a name="12973" href="#12973" class="Bound">l≤x</a><a name="12976" class="Symbol">)</a><a name="12977"> </a><a name="12978" href="#12978" class="Bound">l≤y</a><a name="12981"> </a><a name="12982" href="#12982" class="Bound">y≤u</a><a name="12985"> </a><a name="12986" class="Keyword">with</a><a name="12990"> </a><a name="12991" href="#12960" class="Bound">y</a><a name="12992"> </a><a name="12993" href="#9669" class="Bound Operator">≤?</a><a name="12995"> </a><a name="12996" href="#12968" class="Bound">x</a><a name="12997">
  </a><a name="13000" href="#12824" class="Function">insert</a><a name="13006"> </a><a name="13007" href="#13007" class="Bound">y</a><a name="13008"> </a><a name="13009" class="Symbol">(</a><a name="13010" href="#11665" class="InductiveConstructor">cons</a><a name="13014"> </a><a name="13015" href="#13015" class="Bound">x</a><a name="13016"> </a><a name="13017" href="#13017" class="Bound">xs</a><a name="13019"> </a><a name="13020" href="#13020" class="Bound">l≤x</a><a name="13023" class="Symbol">)</a><a name="13024"> </a><a name="13025" href="#13025" class="Bound">l≤y</a><a name="13028"> </a><a name="13029" href="#13029" class="Bound">y≤u</a><a name="13032"> </a><a name="13033" class="Symbol">|</a><a name="13034"> </a><a name="13035" href="#4538" class="InductiveConstructor">left</a><a name="13039">  </a><a name="13041" href="#13041" class="Bound">y≤x</a><a name="13044"> </a><a name="13045" class="Symbol">=</a><a name="13046"> </a><a name="13047" href="#11665" class="InductiveConstructor">cons</a><a name="13051"> </a><a name="13052" href="#13007" class="Bound">y</a><a name="13053"> </a><a name="13054" class="Symbol">(</a><a name="13055" href="#11665" class="InductiveConstructor">cons</a><a name="13059"> </a><a name="13060" href="#13015" class="Bound">x</a><a name="13061"> </a><a name="13062" href="#13017" class="Bound">xs</a><a name="13064"> </a><a name="13065" class="Symbol">(</a><a name="13066" href="#10575" class="InductiveConstructor">≤-lift</a><a name="13072"> </a><a name="13073" href="#13041" class="Bound">y≤x</a><a name="13076" class="Symbol">))</a><a name="13078"> </a><a name="13079" href="#13025" class="Bound">l≤y</a><a name="13082">
  </a><a name="13085" href="#12824" class="Function">insert</a><a name="13091"> </a><a name="13092" href="#13092" class="Bound">y</a><a name="13093"> </a><a name="13094" class="Symbol">(</a><a name="13095" href="#11665" class="InductiveConstructor">cons</a><a name="13099"> </a><a name="13100" href="#13100" class="Bound">x</a><a name="13101"> </a><a name="13102" href="#13102" class="Bound">xs</a><a name="13104"> </a><a name="13105" href="#13105" class="Bound">l≤x</a><a name="13108" class="Symbol">)</a><a name="13109"> </a><a name="13110" href="#13110" class="Bound">l≤y</a><a name="13113"> </a><a name="13114" href="#13114" class="Bound">y≤u</a><a name="13117"> </a><a name="13118" class="Symbol">|</a><a name="13119"> </a><a name="13120" href="#4563" class="InductiveConstructor">right</a><a name="13125"> </a><a name="13126" href="#13126" class="Bound">y&gt;x</a><a name="13129"> </a><a name="13130" class="Symbol">=</a><a name="13131">
    </a><a name="13136" href="#11665" class="InductiveConstructor">cons</a><a name="13140"> </a><a name="13141" href="#13100" class="Bound">x</a><a name="13142"> </a><a name="13143" class="Symbol">(</a><a name="13144" href="#12824" class="Function">insert</a><a name="13150"> </a><a name="13151" href="#13092" class="Bound">y</a><a name="13152"> </a><a name="13153" href="#13102" class="Bound">xs</a><a name="13155"> </a><a name="13156" class="Symbol">(</a><a name="13157" href="#4587" class="Function Operator">[</a><a name="13158"> </a><a name="13159" href="#10575" class="InductiveConstructor">≤-lift</a><a name="13165"> </a><a name="13166" href="#4587" class="Function Operator">,</a><a name="13167"> </a><a name="13168" class="Symbol">(λ</a><a name="13170"> </a><a name="13171" href="#13171" class="Bound">y≤x</a><a name="13174"> </a><a name="13175" class="Symbol">→</a><a name="13176"> </a><a name="13177" href="#5024" class="Function">absurd</a><a name="13183"> </a><a name="13184" class="Symbol">(</a><a name="13185" href="#13126" class="Bound">y&gt;x</a><a name="13188"> </a><a name="13189" href="#13171" class="Bound">y≤x</a><a name="13192" class="Symbol">))</a><a name="13194"> </a><a name="13195" href="#4587" class="Function Operator">]</a><a name="13196"> </a><a name="13197" class="Symbol">(</a><a name="13198" href="#9218" class="Field">total</a><a name="13203"> </a><a name="13204" href="#13100" class="Bound">x</a><a name="13205"> </a><a name="13206" href="#13092" class="Bound">y</a><a name="13207" class="Symbol">))</a><a name="13209"> </a><a name="13210" href="#13114" class="Bound">y≤u</a><a name="13213" class="Symbol">)</a><a name="13214"> </a><a name="13215" href="#13105" class="Bound">l≤x</a><a name="13218">
</a></code></pre>
<p>Insertion sort is just a fold, where we use the type <code>OList ⊥ ⊤</code> to represent a sorted list with open bounds:</p>
<pre class="Agda"><code><a name="13342" class="Markup"></a><a name="13354">
  </a><a name="13357" href="#13357" class="Function">isort′</a><a name="13363"> </a><a name="13364" class="Symbol">:</a><a name="13365"> </a><a name="13366" href="#2675" class="Datatype">List</a><a name="13370"> </a><a name="13371" href="#9635" class="Bound">X</a><a name="13372"> </a><a name="13373" class="Symbol">→</a><a name="13374"> </a><a name="13375" href="#11601" class="Datatype">OList</a><a name="13380"> </a><a name="13381" href="#10307" class="InductiveConstructor">⊥</a><a name="13382"> </a><a name="13383" href="#10305" class="InductiveConstructor">⊤</a><a name="13384">
  </a><a name="13387" href="#13357" class="Function">isort′</a><a name="13393"> </a><a name="13394" class="Symbol">=</a><a name="13395"> </a><a name="13396" href="#3622" class="Function">foldr</a><a name="13401"> </a><a name="13402" class="Symbol">(λ</a><a name="13404"> </a><a name="13405" href="#13405" class="Bound">x</a><a name="13406"> </a><a name="13407" href="#13407" class="Bound">xs</a><a name="13409"> </a><a name="13410" class="Symbol">→</a><a name="13411"> </a><a name="13412" href="#12824" class="Function">insert</a><a name="13418"> </a><a name="13419" href="#13405" class="Bound">x</a><a name="13420"> </a><a name="13421" href="#13407" class="Bound">xs</a><a name="13423"> </a><a name="13424" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="13427"> </a><a name="13428" href="#10546" class="InductiveConstructor">≤̂⊤</a><a name="13431" class="Symbol">)</a><a name="13432"> </a><a name="13433" class="Symbol">(</a><a name="13434" href="#11635" class="InductiveConstructor">nil</a><a name="13437"> </a><a name="13438" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="13441" class="Symbol">)</a><a name="13442">

  </a><a name="13446" href="#13446" class="Function">isort</a><a name="13451"> </a><a name="13452" class="Symbol">:</a><a name="13453"> </a><a name="13454" href="#2675" class="Datatype">List</a><a name="13458"> </a><a name="13459" href="#9635" class="Bound">X</a><a name="13460"> </a><a name="13461" class="Symbol">→</a><a name="13462"> </a><a name="13463" href="#2675" class="Datatype">List</a><a name="13467"> </a><a name="13468" href="#9635" class="Bound">X</a><a name="13469">
  </a><a name="13472" href="#13446" class="Function">isort</a><a name="13477"> </a><a name="13478" href="#13478" class="Bound">xs</a><a name="13480"> </a><a name="13481" class="Symbol">=</a><a name="13482"> </a><a name="13483" href="#12148" class="Function">toList</a><a name="13489"> </a><a name="13490" class="Symbol">(</a><a name="13491" href="#13357" class="Function">isort′</a><a name="13497"> </a><a name="13498" href="#13478" class="Bound">xs</a><a name="13500" class="Symbol">)</a><a name="13501">
</a></code></pre>
<h3 id="tree-sort">Tree sort <a href="#tree-sort" class="section-link">#</a></h3>
<p>Now for something more efficient, a <a href="https://en.wikipedia.org/wiki/Tree_sort">tree sort</a>. Firstly we’ll define a bounded, ordered binary tree:</p>
<pre class="Agda"><code><a name="13674" class="Markup"></a><a name="13686">
  </a><a name="13689" class="Keyword">data</a><a name="13693"> </a><a name="13694" href="#13694" class="Datatype">Tree</a><a name="13698"> </a><a name="13699" class="Symbol">(</a><a name="13700" href="#13700" class="Bound">l</a><a name="13701"> </a><a name="13702" href="#13702" class="Bound">u</a><a name="13703"> </a><a name="13704" class="Symbol">:</a><a name="13705"> </a><a name="13706" href="#10285" class="Datatype">⊥X⊤</a><a name="13709" class="Symbol">)</a><a name="13710"> </a><a name="13711" class="Symbol">:</a><a name="13712"> </a><a name="13713" class="PrimitiveType">Set</a><a name="13716"> </a><a name="13717" class="Keyword">where</a><a name="13722">
    </a><a name="13727" href="#13727" class="InductiveConstructor">leaf</a><a name="13731"> </a><a name="13732" class="Symbol">:</a><a name="13733"> </a><a name="13734" href="#13700" class="Bound">l</a><a name="13735"> </a><a name="13736" href="#10492" class="Datatype Operator">≤̂</a><a name="13738"> </a><a name="13739" href="#13702" class="Bound">u</a><a name="13740"> </a><a name="13741" class="Symbol">→</a><a name="13742"> </a><a name="13743" href="#13694" class="Datatype">Tree</a><a name="13747"> </a><a name="13748" href="#13700" class="Bound">l</a><a name="13749"> </a><a name="13750" href="#13702" class="Bound">u</a><a name="13751">
    </a><a name="13756" href="#13756" class="InductiveConstructor">node</a><a name="13760"> </a><a name="13761" class="Symbol">:</a><a name="13762"> </a><a name="13763" class="Symbol">(</a><a name="13764" href="#13764" class="Bound">x</a><a name="13765"> </a><a name="13766" class="Symbol">:</a><a name="13767"> </a><a name="13768" href="#9635" class="Bound">X</a><a name="13769" class="Symbol">)</a><a name="13770"> </a><a name="13771" class="Symbol">→</a><a name="13772"> </a><a name="13773" href="#13694" class="Datatype">Tree</a><a name="13777"> </a><a name="13778" href="#13700" class="Bound">l</a><a name="13779"> </a><a name="13780" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="13781"> </a><a name="13782" href="#13764" class="Bound">x</a><a name="13783"> </a><a name="13784" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="13785"> </a><a name="13786" class="Symbol">→</a><a name="13787"> </a><a name="13788" href="#13694" class="Datatype">Tree</a><a name="13792"> </a><a name="13793" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="13794"> </a><a name="13795" href="#13764" class="Bound">x</a><a name="13796"> </a><a name="13797" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="13798"> </a><a name="13799" href="#13702" class="Bound">u</a><a name="13800"> </a><a name="13801" class="Symbol">→</a><a name="13802"> </a><a name="13803" href="#13694" class="Datatype">Tree</a><a name="13807"> </a><a name="13808" href="#13700" class="Bound">l</a><a name="13809"> </a><a name="13810" href="#13702" class="Bound">u</a><a name="13811">
</a></code></pre>
<p>The technique is similar to that employed in <code>OList</code>. Then we need a procedure to insert an element in an existing tree:</p>
<pre class="Agda"><code><a name="13947" class="Markup"></a><a name="13959">
  </a><a name="13962" href="#13962" class="Function">newLeaf</a><a name="13969"> </a><a name="13970" class="Symbol">:</a><a name="13971"> </a><a name="13972" class="Symbol">∀</a><a name="13973"> </a><a name="13974" class="Symbol">{</a><a name="13975" href="#13975" class="Bound">l</a><a name="13976"> </a><a name="13977" href="#13977" class="Bound">u</a><a name="13978" class="Symbol">}</a><a name="13979"> </a><a name="13980" class="Symbol">→</a><a name="13981"> </a><a name="13982" class="Symbol">(</a><a name="13983" href="#13983" class="Bound">x</a><a name="13984"> </a><a name="13985" class="Symbol">:</a><a name="13986"> </a><a name="13987" href="#9635" class="Bound">X</a><a name="13988" class="Symbol">)</a><a name="13989"> </a><a name="13990" class="Symbol">→</a><a name="13991"> </a><a name="13992" href="#13694" class="Datatype">Tree</a><a name="13996"> </a><a name="13997" href="#13975" class="Bound">l</a><a name="13998"> </a><a name="13999" href="#13977" class="Bound">u</a><a name="14000"> </a><a name="14001" class="Symbol">→</a><a name="14002"> </a><a name="14003" href="#13975" class="Bound">l</a><a name="14004"> </a><a name="14005" href="#10492" class="Datatype Operator">≤̂</a><a name="14007"> </a><a name="14008" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="14009"> </a><a name="14010" href="#13983" class="Bound">x</a><a name="14011"> </a><a name="14012" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="14013"> </a><a name="14014" class="Symbol">→</a><a name="14015"> </a><a name="14016" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="14017"> </a><a name="14018" href="#13983" class="Bound">x</a><a name="14019"> </a><a name="14020" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="14021"> </a><a name="14022" href="#10492" class="Datatype Operator">≤̂</a><a name="14024"> </a><a name="14025" href="#13977" class="Bound">u</a><a name="14026"> </a><a name="14027" class="Symbol">→</a><a name="14028"> </a><a name="14029" href="#13694" class="Datatype">Tree</a><a name="14033"> </a><a name="14034" href="#13975" class="Bound">l</a><a name="14035"> </a><a name="14036" href="#13977" class="Bound">u</a><a name="14037">
  </a><a name="14040" href="#13962" class="Function">newLeaf</a><a name="14047"> </a><a name="14048" href="#14048" class="Bound">x</a><a name="14049"> </a><a name="14050" class="Symbol">(</a><a name="14051" href="#13727" class="InductiveConstructor">leaf</a><a name="14055"> </a><a name="14056" class="Symbol">_)</a><a name="14058">       </a><a name="14065" href="#14065" class="Bound">l≤x</a><a name="14068"> </a><a name="14069" href="#14069" class="Bound">x≤u</a><a name="14072"> </a><a name="14073" class="Symbol">=</a><a name="14074"> </a><a name="14075" href="#13756" class="InductiveConstructor">node</a><a name="14079"> </a><a name="14080" href="#14048" class="Bound">x</a><a name="14081"> </a><a name="14082" class="Symbol">(</a><a name="14083" href="#13727" class="InductiveConstructor">leaf</a><a name="14087"> </a><a name="14088" href="#14065" class="Bound">l≤x</a><a name="14091" class="Symbol">)</a><a name="14092"> </a><a name="14093" class="Symbol">(</a><a name="14094" href="#13727" class="InductiveConstructor">leaf</a><a name="14098"> </a><a name="14099" href="#14069" class="Bound">x≤u</a><a name="14102" class="Symbol">)</a><a name="14103">
  </a><a name="14106" href="#13962" class="Function">newLeaf</a><a name="14113"> </a><a name="14114" href="#14114" class="Bound">x</a><a name="14115"> </a><a name="14116" class="Symbol">(</a><a name="14117" href="#13756" class="InductiveConstructor">node</a><a name="14121"> </a><a name="14122" href="#14122" class="Bound">y</a><a name="14123"> </a><a name="14124" href="#14124" class="Bound">ly</a><a name="14126"> </a><a name="14127" href="#14127" class="Bound">yu</a><a name="14129" class="Symbol">)</a><a name="14130"> </a><a name="14131" href="#14131" class="Bound">l≤x</a><a name="14134"> </a><a name="14135" href="#14135" class="Bound">x≤u</a><a name="14138"> </a><a name="14139" class="Keyword">with</a><a name="14143"> </a><a name="14144" href="#14114" class="Bound">x</a><a name="14145"> </a><a name="14146" href="#9669" class="Bound Operator">≤?</a><a name="14148"> </a><a name="14149" href="#14122" class="Bound">y</a><a name="14150">
  </a><a name="14153" href="#13962" class="Function">newLeaf</a><a name="14160"> </a><a name="14161" href="#14161" class="Bound">x</a><a name="14162"> </a><a name="14163" class="Symbol">(</a><a name="14164" href="#13756" class="InductiveConstructor">node</a><a name="14168"> </a><a name="14169" href="#14169" class="Bound">y</a><a name="14170"> </a><a name="14171" href="#14171" class="Bound">ly</a><a name="14173"> </a><a name="14174" href="#14174" class="Bound">yu</a><a name="14176" class="Symbol">)</a><a name="14177"> </a><a name="14178" href="#14178" class="Bound">l≤x</a><a name="14181"> </a><a name="14182" href="#14182" class="Bound">x≤u</a><a name="14185"> </a><a name="14186" class="Symbol">|</a><a name="14187"> </a><a name="14188" href="#4538" class="InductiveConstructor">left</a><a name="14192"> </a><a name="14193" href="#14193" class="Bound">x≤y</a><a name="14196">  </a><a name="14198" class="Symbol">=</a><a name="14199">
    </a><a name="14204" href="#13756" class="InductiveConstructor">node</a><a name="14208"> </a><a name="14209" href="#14169" class="Bound">y</a><a name="14210"> </a><a name="14211" class="Symbol">(</a><a name="14212" href="#13962" class="Function">newLeaf</a><a name="14219"> </a><a name="14220" href="#14161" class="Bound">x</a><a name="14221"> </a><a name="14222" href="#14171" class="Bound">ly</a><a name="14224"> </a><a name="14225" href="#14178" class="Bound">l≤x</a><a name="14228"> </a><a name="14229" class="Symbol">(</a><a name="14230" href="#10575" class="InductiveConstructor">≤-lift</a><a name="14236"> </a><a name="14237" href="#14193" class="Bound">x≤y</a><a name="14240" class="Symbol">))</a><a name="14242"> </a><a name="14243" href="#14174" class="Bound">yu</a><a name="14245">
  </a><a name="14248" href="#13962" class="Function">newLeaf</a><a name="14255"> </a><a name="14256" href="#14256" class="Bound">x</a><a name="14257"> </a><a name="14258" class="Symbol">(</a><a name="14259" href="#13756" class="InductiveConstructor">node</a><a name="14263"> </a><a name="14264" href="#14264" class="Bound">y</a><a name="14265"> </a><a name="14266" href="#14266" class="Bound">ly</a><a name="14268"> </a><a name="14269" href="#14269" class="Bound">yu</a><a name="14271" class="Symbol">)</a><a name="14272"> </a><a name="14273" href="#14273" class="Bound">l≤x</a><a name="14276"> </a><a name="14277" href="#14277" class="Bound">x≤u</a><a name="14280"> </a><a name="14281" class="Symbol">|</a><a name="14282"> </a><a name="14283" href="#4563" class="InductiveConstructor">right</a><a name="14288"> </a><a name="14289" href="#14289" class="Bound">x&gt;y</a><a name="14292"> </a><a name="14293" class="Symbol">=</a><a name="14294">
    </a><a name="14299" href="#13756" class="InductiveConstructor">node</a><a name="14303"> </a><a name="14304" href="#14264" class="Bound">y</a><a name="14305"> </a><a name="14306" href="#14266" class="Bound">ly</a><a name="14308"> </a><a name="14309" class="Symbol">(</a><a name="14310" href="#13962" class="Function">newLeaf</a><a name="14317"> </a><a name="14318" href="#14256" class="Bound">x</a><a name="14319"> </a><a name="14320" href="#14269" class="Bound">yu</a><a name="14322"> </a><a name="14323" class="Symbol">(</a><a name="14324" href="#4587" class="Function Operator">[</a><a name="14325"> </a><a name="14326" class="Symbol">(λ</a><a name="14328"> </a><a name="14329" href="#14329" class="Bound">x≤y</a><a name="14332"> </a><a name="14333" class="Symbol">→</a><a name="14334"> </a><a name="14335" href="#5024" class="Function">absurd</a><a name="14341"> </a><a name="14342" class="Symbol">(</a><a name="14343" href="#14289" class="Bound">x&gt;y</a><a name="14346"> </a><a name="14347" href="#14329" class="Bound">x≤y</a><a name="14350" class="Symbol">))</a><a name="14352"> </a><a name="14353" href="#4587" class="Function Operator">,</a><a name="14354"> </a><a name="14355" href="#10575" class="InductiveConstructor">≤-lift</a><a name="14361"> </a><a name="14362" href="#4587" class="Function Operator">]</a><a name="14363"> </a><a name="14364" class="Symbol">(</a><a name="14365" href="#9218" class="Field">total</a><a name="14370"> </a><a name="14371" href="#14256" class="Bound">x</a><a name="14372"> </a><a name="14373" href="#14264" class="Bound">y</a><a name="14374" class="Symbol">))</a><a name="14376"> </a><a name="14377" href="#14277" class="Bound">x≤u</a><a name="14380" class="Symbol">)</a><a name="14381">
</a></code></pre>
<p>Again, the only tricky bit is the last one, where we need to convince Agda that <code>y ≤ x</code> given that <code>¬ (x ≤ y)</code>.</p>
<p>Similar to <code>isort′</code>, turning a <code>List</code> into a <code>Tree</code> is a simple fold:</p>
<pre class="Agda"><code><a name="14578" class="Markup"></a><a name="14590">
  </a><a name="14593" href="#14593" class="Function">fromList</a><a name="14601"> </a><a name="14602" class="Symbol">:</a><a name="14603"> </a><a name="14604" href="#2675" class="Datatype">List</a><a name="14608"> </a><a name="14609" href="#9635" class="Bound">X</a><a name="14610"> </a><a name="14611" class="Symbol">→</a><a name="14612"> </a><a name="14613" href="#13694" class="Datatype">Tree</a><a name="14617"> </a><a name="14618" href="#10307" class="InductiveConstructor">⊥</a><a name="14619"> </a><a name="14620" href="#10305" class="InductiveConstructor">⊤</a><a name="14621">
  </a><a name="14624" href="#14593" class="Function">fromList</a><a name="14632"> </a><a name="14633" class="Symbol">=</a><a name="14634"> </a><a name="14635" href="#3622" class="Function">foldr</a><a name="14640"> </a><a name="14641" class="Symbol">(λ</a><a name="14643"> </a><a name="14644" href="#14644" class="Bound">x</a><a name="14645"> </a><a name="14646" href="#14646" class="Bound">xs</a><a name="14648"> </a><a name="14649" class="Symbol">→</a><a name="14650"> </a><a name="14651" href="#13962" class="Function">newLeaf</a><a name="14658"> </a><a name="14659" href="#14644" class="Bound">x</a><a name="14660"> </a><a name="14661" href="#14646" class="Bound">xs</a><a name="14663"> </a><a name="14664" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="14667"> </a><a name="14668" href="#10546" class="InductiveConstructor">≤̂⊤</a><a name="14671" class="Symbol">)</a><a name="14672"> </a><a name="14673" class="Symbol">(</a><a name="14674" href="#13727" class="InductiveConstructor">leaf</a><a name="14678"> </a><a name="14679" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="14682" class="Symbol">)</a><a name="14683">
</a></code></pre>
<p>Now we can define <code>OList</code> concatenation, with the twist of inserting a new element in the middle; and finally <code>flatten</code>:</p>
<pre class="Agda"><code><a name="14818" class="Markup"></a><a name="14830">
  </a><a name="14833" href="#14833" class="Function Operator">_⇒_++_</a><a name="14839"> </a><a name="14840" class="Symbol">:</a><a name="14841"> </a><a name="14842" class="Symbol">∀</a><a name="14843"> </a><a name="14844" class="Symbol">{</a><a name="14845" href="#14845" class="Bound">l</a><a name="14846"> </a><a name="14847" href="#14847" class="Bound">u</a><a name="14848" class="Symbol">}</a><a name="14849"> </a><a name="14850" href="#14850" class="Bound">x</a><a name="14851"> </a><a name="14852" class="Symbol">→</a><a name="14853"> </a><a name="14854" href="#11601" class="Datatype">OList</a><a name="14859"> </a><a name="14860" href="#14845" class="Bound">l</a><a name="14861"> </a><a name="14862" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="14863"> </a><a name="14864" href="#14850" class="Bound">x</a><a name="14865"> </a><a name="14866" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="14867"> </a><a name="14868" class="Symbol">→</a><a name="14869"> </a><a name="14870" href="#11601" class="Datatype">OList</a><a name="14875"> </a><a name="14876" href="#10319" class="InductiveConstructor Operator">⟦</a><a name="14877"> </a><a name="14878" href="#14850" class="Bound">x</a><a name="14879"> </a><a name="14880" href="#10319" class="InductiveConstructor Operator">⟧</a><a name="14881"> </a><a name="14882" href="#14847" class="Bound">u</a><a name="14883"> </a><a name="14884" class="Symbol">→</a><a name="14885"> </a><a name="14886" href="#11601" class="Datatype">OList</a><a name="14891"> </a><a name="14892" href="#14845" class="Bound">l</a><a name="14893"> </a><a name="14894" href="#14847" class="Bound">u</a><a name="14895">
  </a><a name="14898" href="#14898" class="Bound">x</a><a name="14899"> </a><a name="14900" href="#14833" class="Function Operator">⇒</a><a name="14901"> </a><a name="14902" href="#11635" class="InductiveConstructor">nil</a><a name="14905"> </a><a name="14906" href="#14906" class="Bound">l≤u</a><a name="14909">       </a><a name="14916" href="#14833" class="Function Operator">++</a><a name="14918"> </a><a name="14919" href="#14919" class="Bound">xu</a><a name="14921"> </a><a name="14922" class="Symbol">=</a><a name="14923"> </a><a name="14924" href="#11665" class="InductiveConstructor">cons</a><a name="14928"> </a><a name="14929" href="#14898" class="Bound">x</a><a name="14930"> </a><a name="14931" href="#14919" class="Bound">xu</a><a name="14933"> </a><a name="14934" href="#14906" class="Bound">l≤u</a><a name="14937">
  </a><a name="14940" href="#14940" class="Bound">x</a><a name="14941"> </a><a name="14942" href="#14833" class="Function Operator">⇒</a><a name="14943"> </a><a name="14944" href="#11665" class="InductiveConstructor">cons</a><a name="14948"> </a><a name="14949" href="#14949" class="Bound">y</a><a name="14950"> </a><a name="14951" href="#14951" class="Bound">yx</a><a name="14953"> </a><a name="14954" href="#14954" class="Bound">l≤y</a><a name="14957"> </a><a name="14958" href="#14833" class="Function Operator">++</a><a name="14960"> </a><a name="14961" href="#14961" class="Bound">xu</a><a name="14963"> </a><a name="14964" class="Symbol">=</a><a name="14965"> </a><a name="14966" href="#11665" class="InductiveConstructor">cons</a><a name="14970"> </a><a name="14971" href="#14949" class="Bound">y</a><a name="14972"> </a><a name="14973" class="Symbol">(</a><a name="14974" href="#14940" class="Bound">x</a><a name="14975"> </a><a name="14976" href="#14833" class="Function Operator">⇒</a><a name="14977"> </a><a name="14978" href="#14951" class="Bound">yx</a><a name="14980"> </a><a name="14981" href="#14833" class="Function Operator">++</a><a name="14983"> </a><a name="14984" href="#14961" class="Bound">xu</a><a name="14986" class="Symbol">)</a><a name="14987"> </a><a name="14988" href="#14954" class="Bound">l≤y</a><a name="14991">

  </a><a name="14995" href="#14995" class="Function">flatten</a><a name="15002"> </a><a name="15003" class="Symbol">:</a><a name="15004"> </a><a name="15005" class="Symbol">∀</a><a name="15006"> </a><a name="15007" class="Symbol">{</a><a name="15008" href="#15008" class="Bound">l</a><a name="15009"> </a><a name="15010" href="#15010" class="Bound">u</a><a name="15011" class="Symbol">}</a><a name="15012"> </a><a name="15013" class="Symbol">→</a><a name="15014"> </a><a name="15015" href="#13694" class="Datatype">Tree</a><a name="15019"> </a><a name="15020" href="#15008" class="Bound">l</a><a name="15021"> </a><a name="15022" href="#15010" class="Bound">u</a><a name="15023"> </a><a name="15024" class="Symbol">→</a><a name="15025"> </a><a name="15026" href="#11601" class="Datatype">OList</a><a name="15031"> </a><a name="15032" href="#15008" class="Bound">l</a><a name="15033"> </a><a name="15034" href="#15010" class="Bound">u</a><a name="15035">
  </a><a name="15038" href="#14995" class="Function">flatten</a><a name="15045"> </a><a name="15046" class="Symbol">(</a><a name="15047" href="#13727" class="InductiveConstructor">leaf</a><a name="15051"> </a><a name="15052" href="#15052" class="Bound">l≤u</a><a name="15055" class="Symbol">)</a><a name="15056">     </a><a name="15061" class="Symbol">=</a><a name="15062"> </a><a name="15063" class="Symbol">(</a><a name="15064" href="#11635" class="InductiveConstructor">nil</a><a name="15067"> </a><a name="15068" href="#15052" class="Bound">l≤u</a><a name="15071" class="Symbol">)</a><a name="15072">
  </a><a name="15075" href="#14995" class="Function">flatten</a><a name="15082"> </a><a name="15083" class="Symbol">(</a><a name="15084" href="#13756" class="InductiveConstructor">node</a><a name="15088"> </a><a name="15089" href="#15089" class="Bound">x</a><a name="15090"> </a><a name="15091" href="#15091" class="Bound">lx</a><a name="15093"> </a><a name="15094" href="#15094" class="Bound">xu</a><a name="15096" class="Symbol">)</a><a name="15097"> </a><a name="15098" class="Symbol">=</a><a name="15099"> </a><a name="15100" href="#15089" class="Bound">x</a><a name="15101"> </a><a name="15102" href="#14833" class="Function Operator">⇒</a><a name="15103"> </a><a name="15104" href="#14995" class="Function">flatten</a><a name="15111"> </a><a name="15112" href="#15091" class="Bound">lx</a><a name="15114"> </a><a name="15115" href="#14833" class="Function Operator">++</a><a name="15117"> </a><a name="15118" href="#14995" class="Function">flatten</a><a name="15125"> </a><a name="15126" href="#15094" class="Bound">xu</a><a name="15128">
</a></code></pre>
<p>Then we are good with yet another fold.</p>
<pre class="Agda"><code><a name="15182" class="Markup"></a><a name="15194">
  </a><a name="15197" href="#15197" class="Function">treeSort′</a><a name="15206"> </a><a name="15207" class="Symbol">:</a><a name="15208"> </a><a name="15209" href="#2675" class="Datatype">List</a><a name="15213"> </a><a name="15214" href="#9635" class="Bound">X</a><a name="15215"> </a><a name="15216" class="Symbol">→</a><a name="15217"> </a><a name="15218" href="#11601" class="Datatype">OList</a><a name="15223"> </a><a name="15224" href="#10307" class="InductiveConstructor">⊥</a><a name="15225"> </a><a name="15226" href="#10305" class="InductiveConstructor">⊤</a><a name="15227">
  </a><a name="15230" href="#15197" class="Function">treeSort′</a><a name="15239"> </a><a name="15240" href="#15240" class="Bound">xs</a><a name="15242"> </a><a name="15243" class="Symbol">=</a><a name="15244"> </a><a name="15245" href="#14995" class="Function">flatten</a><a name="15252"> </a><a name="15253" class="Symbol">(</a><a name="15254" href="#3622" class="Function">foldr</a><a name="15259"> </a><a name="15260" class="Symbol">(λ</a><a name="15262"> </a><a name="15263" href="#15263" class="Bound">x</a><a name="15264"> </a><a name="15265" href="#15265" class="Bound">xs</a><a name="15267"> </a><a name="15268" class="Symbol">→</a><a name="15269"> </a><a name="15270" href="#13962" class="Function">newLeaf</a><a name="15277"> </a><a name="15278" href="#15263" class="Bound">x</a><a name="15279"> </a><a name="15280" href="#15265" class="Bound">xs</a><a name="15282"> </a><a name="15283" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="15286"> </a><a name="15287" href="#10546" class="InductiveConstructor">≤̂⊤</a><a name="15290" class="Symbol">)</a><a name="15291"> </a><a name="15292" class="Symbol">(</a><a name="15293" href="#13727" class="InductiveConstructor">leaf</a><a name="15297"> </a><a name="15298" href="#10517" class="InductiveConstructor">⊥≤̂</a><a name="15301" class="Symbol">)</a><a name="15302"> </a><a name="15303" href="#15240" class="Bound">xs</a><a name="15305" class="Symbol">)</a><a name="15306">

  </a><a name="15310" href="#15310" class="Function">treeSort</a><a name="15318"> </a><a name="15319" class="Symbol">:</a><a name="15320"> </a><a name="15321" href="#2675" class="Datatype">List</a><a name="15325"> </a><a name="15326" href="#9635" class="Bound">X</a><a name="15327"> </a><a name="15328" class="Symbol">→</a><a name="15329"> </a><a name="15330" href="#2675" class="Datatype">List</a><a name="15334"> </a><a name="15335" href="#9635" class="Bound">X</a><a name="15336">
  </a><a name="15339" href="#15310" class="Function">treeSort</a><a name="15347"> </a><a name="15348" href="#15348" class="Bound">xs</a><a name="15350"> </a><a name="15351" class="Symbol">=</a><a name="15352"> </a><a name="15353" href="#12148" class="Function">toList</a><a name="15359"> </a><a name="15360" class="Symbol">(</a><a name="15361" href="#15197" class="Function">treeSort′</a><a name="15370"> </a><a name="15371" href="#15348" class="Bound">xs</a><a name="15373" class="Symbol">)</a><a name="15374">
</a></code></pre>
<h2 id="propositional-equality">Propositional equality <a href="#propositional-equality" class="section-link">#</a></h2>
<p>Now lets put our module to work. We will need a type equipped with the appropriate relations: in this post I am going to use natural numbers.</p>
<p>For what concerns equality, we can actually define an inductive family that relates equal terms:</p>
<pre class="Agda"><code><a name="15656" class="Markup"></a><a name="15668">
</a><a name="15669" class="Keyword">module</a><a name="15675"> </a><a name="15676" href="#15676" class="Module">PropositionalEquality</a><a name="15697"> </a><a name="15698" class="Keyword">where</a><a name="15703">
  </a><a name="15706" class="Keyword">data</a><a name="15710"> </a><a name="15711" href="#15711" class="Datatype Operator">_≡_</a><a name="15714"> </a><a name="15715" class="Symbol">{</a><a name="15716" href="#15716" class="Bound">X</a><a name="15717" class="Symbol">}</a><a name="15718"> </a><a name="15719" class="Symbol">:</a><a name="15720"> </a><a name="15721" href="#7215" class="Function">Rel</a><a name="15724"> </a><a name="15725" href="#15716" class="Bound">X</a><a name="15726"> </a><a name="15727" class="Keyword">where</a><a name="15732">
    </a><a name="15737" href="#15737" class="InductiveConstructor">refl</a><a name="15741"> </a><a name="15742" class="Symbol">:</a><a name="15743"> </a><a name="15744" class="Symbol">∀</a><a name="15745"> </a><a name="15746" class="Symbol">{</a><a name="15747" href="#15747" class="Bound">x</a><a name="15748" class="Symbol">}</a><a name="15749"> </a><a name="15750" class="Symbol">→</a><a name="15751"> </a><a name="15752" href="#15747" class="Bound">x</a><a name="15753"> </a><a name="15754" href="#15711" class="Datatype Operator">≡</a><a name="15755"> </a><a name="15756" href="#15747" class="Bound">x</a><a name="15757">
</a></code></pre>
<p>It’s worth mentioning what equal means here. I have mentioned earlier that “evaluation and typechecking are intertwined”: when the type checker has to decide if two types, or more generally two terms, are “the same”, it simply reduces them as far as possible (to their <em>normal form</em>) and then compares them syntactically, plus some additional laws.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Remember, every Agda term is terminating, so this procedure itself is guaranteed to terminate. Thus, <code>refl : ((λ x → x) 1) ≡ 1</code> is acceptable, and so on.</p>
<p>This notion of equality is often called <em>definitional equality</em>, as opposed to the user-level equality expressed by the inductive family we have just defined, which takes the name of <em>propositional equality</em>. Note that having a prop. equality in scope <em>does not</em> imply definitional equality for the related terms, unless the prop. equality is a closed term.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> In the general case we might have prop. equalities in scope that do not necessarily hold or involve abstracted variables, think of <code>λ (p : 3 ≡ 1) → ...</code>.</p>
<p>Let’s prove that <code>≡</code> is an equivalence relation, and a <code>cong</code>ruence law which will be useful later:</p>
<pre class="Agda"><code><a name="17556" class="Markup"></a><a name="17568">
  </a><a name="17571" href="#17571" class="Function">sym</a><a name="17574"> </a><a name="17575" class="Symbol">:</a><a name="17576"> </a><a name="17577" class="Symbol">∀</a><a name="17578"> </a><a name="17579" class="Symbol">{</a><a name="17580" href="#17580" class="Bound">X</a><a name="17581" class="Symbol">}</a><a name="17582"> </a><a name="17583" class="Symbol">{</a><a name="17584" href="#17584" class="Bound">x</a><a name="17585"> </a><a name="17586" href="#17586" class="Bound">y</a><a name="17587"> </a><a name="17588" class="Symbol">:</a><a name="17589"> </a><a name="17590" href="#17580" class="Bound">X</a><a name="17591" class="Symbol">}</a><a name="17592"> </a><a name="17593" class="Symbol">→</a><a name="17594"> </a><a name="17595" href="#17584" class="Bound">x</a><a name="17596"> </a><a name="17597" href="#15711" class="Datatype Operator">≡</a><a name="17598"> </a><a name="17599" href="#17586" class="Bound">y</a><a name="17600"> </a><a name="17601" class="Symbol">→</a><a name="17602"> </a><a name="17603" href="#17586" class="Bound">y</a><a name="17604"> </a><a name="17605" href="#15711" class="Datatype Operator">≡</a><a name="17606"> </a><a name="17607" href="#17584" class="Bound">x</a><a name="17608">
  </a><a name="17611" href="#17571" class="Function">sym</a><a name="17614"> </a><a name="17615" href="#15737" class="InductiveConstructor">refl</a><a name="17619"> </a><a name="17620" class="Symbol">=</a><a name="17621"> </a><a name="17622" href="#15737" class="InductiveConstructor">refl</a><a name="17626">

  </a><a name="17630" href="#17630" class="Function">trans</a><a name="17635"> </a><a name="17636" class="Symbol">:</a><a name="17637"> </a><a name="17638" class="Symbol">∀</a><a name="17639"> </a><a name="17640" class="Symbol">{</a><a name="17641" href="#17641" class="Bound">X</a><a name="17642" class="Symbol">}</a><a name="17643"> </a><a name="17644" class="Symbol">{</a><a name="17645" href="#17645" class="Bound">x</a><a name="17646"> </a><a name="17647" href="#17647" class="Bound">y</a><a name="17648"> </a><a name="17649" href="#17649" class="Bound">z</a><a name="17650"> </a><a name="17651" class="Symbol">:</a><a name="17652"> </a><a name="17653" href="#17641" class="Bound">X</a><a name="17654" class="Symbol">}</a><a name="17655"> </a><a name="17656" class="Symbol">→</a><a name="17657"> </a><a name="17658" href="#17645" class="Bound">x</a><a name="17659"> </a><a name="17660" href="#15711" class="Datatype Operator">≡</a><a name="17661"> </a><a name="17662" href="#17647" class="Bound">y</a><a name="17663"> </a><a name="17664" class="Symbol">→</a><a name="17665"> </a><a name="17666" href="#17647" class="Bound">y</a><a name="17667"> </a><a name="17668" href="#15711" class="Datatype Operator">≡</a><a name="17669"> </a><a name="17670" href="#17649" class="Bound">z</a><a name="17671"> </a><a name="17672" class="Symbol">→</a><a name="17673"> </a><a name="17674" href="#17645" class="Bound">x</a><a name="17675"> </a><a name="17676" href="#15711" class="Datatype Operator">≡</a><a name="17677"> </a><a name="17678" href="#17649" class="Bound">z</a><a name="17679">
  </a><a name="17682" href="#17630" class="Function">trans</a><a name="17687"> </a><a name="17688" href="#15737" class="InductiveConstructor">refl</a><a name="17692"> </a><a name="17693" href="#15737" class="InductiveConstructor">refl</a><a name="17697"> </a><a name="17698" class="Symbol">=</a><a name="17699"> </a><a name="17700" href="#15737" class="InductiveConstructor">refl</a><a name="17704">

  </a><a name="17708" href="#17708" class="Function">equivalence</a><a name="17719"> </a><a name="17720" class="Symbol">:</a><a name="17721"> </a><a name="17722" class="Symbol">∀</a><a name="17723"> </a><a name="17724" class="Symbol">{</a><a name="17725" href="#17725" class="Bound">X</a><a name="17726" class="Symbol">}</a><a name="17727"> </a><a name="17728" class="Symbol">→</a><a name="17729"> </a><a name="17730" href="#8683" class="Record">Equivalence</a><a name="17741"> </a><a name="17742" class="Symbol">{</a><a name="17743" href="#17725" class="Bound">X</a><a name="17744" class="Symbol">}</a><a name="17745"> </a><a name="17746" href="#15711" class="Datatype Operator">_≡_</a><a name="17749">
  </a><a name="17752" href="#17708" class="Function">equivalence</a><a name="17763"> </a><a name="17764" class="Symbol">=</a><a name="17765"> </a><a name="17766" class="Keyword">record</a><a name="17772"> </a><a name="17773" class="Symbol">{</a><a name="17774"> </a><a name="17775" href="#8738" class="Field">refl</a><a name="17779"> </a><a name="17780" class="Symbol">=</a><a name="17781"> </a><a name="17782" href="#15737" class="InductiveConstructor">refl</a><a name="17786" class="Symbol">;</a><a name="17787"> </a><a name="17788" href="#8768" class="Field">sym</a><a name="17791"> </a><a name="17792" class="Symbol">=</a><a name="17793"> </a><a name="17794" href="#17571" class="Function">sym</a><a name="17797" class="Symbol">;</a><a name="17798"> </a><a name="17799" href="#8806" class="Field">trans</a><a name="17804"> </a><a name="17805" class="Symbol">=</a><a name="17806"> </a><a name="17807" href="#17630" class="Function">trans</a><a name="17812"> </a><a name="17813" class="Symbol">}</a><a name="17814">

  </a><a name="17818" href="#17818" class="Function">cong</a><a name="17822"> </a><a name="17823" class="Symbol">:</a><a name="17824"> </a><a name="17825" class="Symbol">∀</a><a name="17826"> </a><a name="17827" class="Symbol">{</a><a name="17828" href="#17828" class="Bound">X</a><a name="17829" class="Symbol">}</a><a name="17830"> </a><a name="17831" class="Symbol">{</a><a name="17832" href="#17832" class="Bound">x</a><a name="17833"> </a><a name="17834" href="#17834" class="Bound">y</a><a name="17835"> </a><a name="17836" class="Symbol">:</a><a name="17837"> </a><a name="17838" href="#17828" class="Bound">X</a><a name="17839" class="Symbol">}</a><a name="17840"> </a><a name="17841" class="Symbol">→</a><a name="17842"> </a><a name="17843" class="Symbol">(</a><a name="17844" href="#17844" class="Bound">f</a><a name="17845"> </a><a name="17846" class="Symbol">:</a><a name="17847"> </a><a name="17848" href="#17828" class="Bound">X</a><a name="17849"> </a><a name="17850" class="Symbol">→</a><a name="17851"> </a><a name="17852" href="#17828" class="Bound">X</a><a name="17853" class="Symbol">)</a><a name="17854"> </a><a name="17855" class="Symbol">→</a><a name="17856"> </a><a name="17857" href="#17832" class="Bound">x</a><a name="17858"> </a><a name="17859" href="#15711" class="Datatype Operator">≡</a><a name="17860"> </a><a name="17861" href="#17834" class="Bound">y</a><a name="17862"> </a><a name="17863" class="Symbol">→</a><a name="17864"> </a><a name="17865" href="#17844" class="Bound">f</a><a name="17866"> </a><a name="17867" href="#17832" class="Bound">x</a><a name="17868"> </a><a name="17869" href="#15711" class="Datatype Operator">≡</a><a name="17870"> </a><a name="17871" href="#17844" class="Bound">f</a><a name="17872"> </a><a name="17873" href="#17834" class="Bound">y</a><a name="17874">
  </a><a name="17877" href="#17818" class="Function">cong</a><a name="17881"> </a><a name="17882" class="Symbol">_</a><a name="17883"> </a><a name="17884" href="#15737" class="InductiveConstructor">refl</a><a name="17888"> </a><a name="17889" class="Symbol">=</a><a name="17890"> </a><a name="17891" href="#15737" class="InductiveConstructor">refl</a><a name="17895">
</a></code></pre>
<p>Here we use pattern matching in a new way: since the value of the indices of <code>≡</code> depends on the constructors, matching on a constructor refines the context with the new information. For example in <code>sym</code> pattern matching <code>refl</code> will unify <code>y</code> and <code>x</code>, turning them into the same variable in the context for the body of <code>sym</code>, and thus letting us invoke <code>refl</code> again. Pattern matching is a much more powerful notion in Agda that is in in most (even dependently typed) programming languages—it can not only change the context, but it will also constraint the possible constructors of other parameters, if they are of a type with indices and those indices have been refined. This collection of techniques is known as <em>dependent pattern matching</em>.</p>
<h2 id="natural-numbers">Natural numbers <a href="#natural-numbers" class="section-link">#</a></h2>
<pre class="Agda"><code><a name="18677" class="Markup"></a><a name="18689">
</a><a name="18690" class="Keyword">module</a><a name="18696"> </a><a name="18697" href="#18697" class="Module">Nat</a><a name="18700"> </a><a name="18701" class="Keyword">where</a><a name="18706">
  </a><a name="18709" class="Keyword">data</a><a name="18713"> </a><a name="18714" href="#18714" class="Datatype">ℕ</a><a name="18715"> </a><a name="18716" class="Symbol">:</a><a name="18717"> </a><a name="18718" class="PrimitiveType">Set</a><a name="18721"> </a><a name="18722" class="Keyword">where</a><a name="18727">
    </a><a name="18732" href="#18732" class="InductiveConstructor">zero</a><a name="18736"> </a><a name="18737" class="Symbol">:</a><a name="18738"> </a><a name="18739" href="#18714" class="Datatype">ℕ</a><a name="18740">
    </a><a name="18745" href="#18745" class="InductiveConstructor">suc</a><a name="18748">  </a><a name="18750" class="Symbol">:</a><a name="18751"> </a><a name="18752" href="#18714" class="Datatype">ℕ</a><a name="18753"> </a><a name="18754" class="Symbol">→</a><a name="18755"> </a><a name="18756" href="#18714" class="Datatype">ℕ</a><a name="18757">

  </a><a name="18761" class="Symbol">{-#</a><a name="18764"> </a><a name="18765" class="Keyword">BUILTIN</a><a name="18772"> </a><a name="18773" class="Keyword">NATURAL</a><a name="18780"> </a><a name="18781" href="#18714" class="Datatype">ℕ</a><a name="18782">    </a><a name="18786" class="Symbol">#-}</a><a name="18789">
</a></code></pre>
<p>The definition for naturals is the usual one—the pragmas are there so that we can use number literals.</p>
<p>Now for our ordering relation. Every number is greater or equal than zero, and if <code>x ≤ y</code> then <code>x + 1 ≤ y + 1</code>:</p>
<pre class="Agda"><code><a name="19022" class="Markup"></a><a name="19034">
  </a><a name="19037" class="Keyword">data</a><a name="19041"> </a><a name="19042" href="#19042" class="Datatype Operator">_≤_</a><a name="19045"> </a><a name="19046" class="Symbol">:</a><a name="19047"> </a><a name="19048" href="#7215" class="Function">Rel</a><a name="19051"> </a><a name="19052" href="#18714" class="Datatype">ℕ</a><a name="19053"> </a><a name="19054" class="Keyword">where</a><a name="19059">
    </a><a name="19064" href="#19064" class="InductiveConstructor">z≤n</a><a name="19067"> </a><a name="19068" class="Symbol">:</a><a name="19069"> </a><a name="19070" class="Symbol">∀</a><a name="19071"> </a><a name="19072" class="Symbol">{</a><a name="19073" href="#19073" class="Bound">x</a><a name="19074" class="Symbol">}</a><a name="19075">   </a><a name="19078" class="Symbol">→</a><a name="19079"> </a><a name="19080" href="#18732" class="InductiveConstructor">zero</a><a name="19084"> </a><a name="19085" href="#19042" class="Datatype Operator">≤</a><a name="19086"> </a><a name="19087" href="#19073" class="Bound">x</a><a name="19088">
    </a><a name="19093" href="#19093" class="InductiveConstructor">s≤s</a><a name="19096"> </a><a name="19097" class="Symbol">:</a><a name="19098"> </a><a name="19099" class="Symbol">∀</a><a name="19100"> </a><a name="19101" class="Symbol">{</a><a name="19102" href="#19102" class="Bound">x</a><a name="19103"> </a><a name="19104" href="#19104" class="Bound">y</a><a name="19105" class="Symbol">}</a><a name="19106"> </a><a name="19107" class="Symbol">→</a><a name="19108"> </a><a name="19109" href="#19102" class="Bound">x</a><a name="19110"> </a><a name="19111" href="#19042" class="Datatype Operator">≤</a><a name="19112"> </a><a name="19113" href="#19104" class="Bound">y</a><a name="19114"> </a><a name="19115" class="Symbol">→</a><a name="19116"> </a><a name="19117" href="#18745" class="InductiveConstructor">suc</a><a name="19120"> </a><a name="19121" href="#19102" class="Bound">x</a><a name="19122"> </a><a name="19123" href="#19042" class="Datatype Operator">≤</a><a name="19124"> </a><a name="19125" href="#18745" class="InductiveConstructor">suc</a><a name="19128"> </a><a name="19129" href="#19104" class="Bound">y</a><a name="19130">
</a></code></pre>
<p>With the help of the dual of <code>s≤s</code>, we can write our decision function for <code>≤</code>:</p>
<pre class="Agda"><code><a name="19224" class="Markup"></a><a name="19236">
  </a><a name="19239" href="#19239" class="Function">≤-suc</a><a name="19244"> </a><a name="19245" class="Symbol">:</a><a name="19246"> </a><a name="19247" class="Symbol">∀</a><a name="19248"> </a><a name="19249" class="Symbol">{</a><a name="19250" href="#19250" class="Bound">x</a><a name="19251"> </a><a name="19252" href="#19252" class="Bound">y</a><a name="19253" class="Symbol">}</a><a name="19254"> </a><a name="19255" class="Symbol">→</a><a name="19256"> </a><a name="19257" href="#18745" class="InductiveConstructor">suc</a><a name="19260"> </a><a name="19261" href="#19250" class="Bound">x</a><a name="19262"> </a><a name="19263" href="#19042" class="Datatype Operator">≤</a><a name="19264"> </a><a name="19265" href="#18745" class="InductiveConstructor">suc</a><a name="19268"> </a><a name="19269" href="#19252" class="Bound">y</a><a name="19270"> </a><a name="19271" class="Symbol">→</a><a name="19272"> </a><a name="19273" href="#19250" class="Bound">x</a><a name="19274"> </a><a name="19275" href="#19042" class="Datatype Operator">≤</a><a name="19276"> </a><a name="19277" href="#19252" class="Bound">y</a><a name="19278">
  </a><a name="19281" href="#19239" class="Function">≤-suc</a><a name="19286"> </a><a name="19287" class="Symbol">(</a><a name="19288" href="#19093" class="InductiveConstructor">s≤s</a><a name="19291"> </a><a name="19292" href="#19292" class="Bound">x≤y</a><a name="19295" class="Symbol">)</a><a name="19296"> </a><a name="19297" class="Symbol">=</a><a name="19298"> </a><a name="19299" href="#19292" class="Bound">x≤y</a><a name="19302">

  </a><a name="19306" href="#19306" class="Function Operator">_≤?_</a><a name="19310"> </a><a name="19311" class="Symbol">:</a><a name="19312"> </a><a name="19313" href="#7961" class="Function">Decidable</a><a name="19322"> </a><a name="19323" href="#19042" class="Datatype Operator">_≤_</a><a name="19326">
  </a><a name="19329" href="#18732" class="InductiveConstructor">zero</a><a name="19333">  </a><a name="19335" href="#19306" class="Function Operator">≤?</a><a name="19337"> </a><a name="19338" class="Symbol">_</a><a name="19339">     </a><a name="19344" class="Symbol">=</a><a name="19345"> </a><a name="19346" href="#4538" class="InductiveConstructor">left</a><a name="19350"> </a><a name="19351" href="#19064" class="InductiveConstructor">z≤n</a><a name="19354">
  </a><a name="19357" href="#18745" class="InductiveConstructor">suc</a><a name="19360"> </a><a name="19361" class="Symbol">_</a><a name="19362"> </a><a name="19363" href="#19306" class="Function Operator">≤?</a><a name="19365"> </a><a name="19366" href="#18732" class="InductiveConstructor">zero</a><a name="19370">  </a><a name="19372" class="Symbol">=</a><a name="19373"> </a><a name="19374" href="#4563" class="InductiveConstructor">right</a><a name="19379"> </a><a name="19380" class="Symbol">λ()</a><a name="19383">
  </a><a name="19386" href="#18745" class="InductiveConstructor">suc</a><a name="19389"> </a><a name="19390" href="#19390" class="Bound">x</a><a name="19391"> </a><a name="19392" href="#19306" class="Function Operator">≤?</a><a name="19394"> </a><a name="19395" href="#18745" class="InductiveConstructor">suc</a><a name="19398"> </a><a name="19399" href="#19399" class="Bound">y</a><a name="19400"> </a><a name="19401" class="Keyword">with</a><a name="19405"> </a><a name="19406" href="#19390" class="Bound">x</a><a name="19407"> </a><a name="19408" href="#19306" class="Function Operator">≤?</a><a name="19410"> </a><a name="19411" href="#19399" class="Bound">y</a><a name="19412">
  </a><a name="19415" class="Symbol">...</a><a name="19418"> </a><a name="19419" class="Symbol">|</a><a name="19420"> </a><a name="19421" href="#4538" class="InductiveConstructor">left</a><a name="19425"> </a><a name="19426" href="#19426" class="Bound">x≤y</a><a name="19429">  </a><a name="19431" class="Symbol">=</a><a name="19432"> </a><a name="19433" href="#4538" class="InductiveConstructor">left</a><a name="19437">  </a><a name="19439" class="Symbol">(</a><a name="19440" href="#19093" class="InductiveConstructor">s≤s</a><a name="19443"> </a><a name="19444" href="#19426" class="Bound">x≤y</a><a name="19447" class="Symbol">)</a><a name="19448">
  </a><a name="19451" class="Symbol">...</a><a name="19454"> </a><a name="19455" class="Symbol">|</a><a name="19456"> </a><a name="19457" href="#4563" class="InductiveConstructor">right</a><a name="19462"> </a><a name="19463" href="#19463" class="Bound">x&gt;y</a><a name="19466"> </a><a name="19467" class="Symbol">=</a><a name="19468"> </a><a name="19469" href="#4563" class="InductiveConstructor">right</a><a name="19474"> </a><a name="19475" class="Symbol">(λ</a><a name="19477"> </a><a name="19478" href="#19478" class="Bound">sx≤sy</a><a name="19483"> </a><a name="19484" class="Symbol">→</a><a name="19485"> </a><a name="19486" href="#19463" class="Bound">x&gt;y</a><a name="19489"> </a><a name="19490" class="Symbol">(</a><a name="19491" href="#19239" class="Function">≤-suc</a><a name="19496"> </a><a name="19497" href="#19478" class="Bound">sx≤sy</a><a name="19502" class="Symbol">))</a><a name="19504">
</a></code></pre>
<p>And the required laws to make a total order out of <code>≤</code>:</p>
<pre class="Agda"><code><a name="19574" class="Markup"></a><a name="19586">
  </a><a name="19589" class="Keyword">open</a><a name="19593"> </a><a name="19594" href="#15676" class="Module">PropositionalEquality</a><a name="19615"> </a><a name="19616" class="Keyword">using</a><a name="19621"> </a><a name="19622" class="Symbol">(</a><a name="19623" href="#15711" class="Datatype Operator">_≡_</a><a name="19626" class="Symbol">;</a><a name="19627"> </a><a name="19628" href="#15737" class="InductiveConstructor">refl</a><a name="19632" class="Symbol">;</a><a name="19633"> </a><a name="19634" href="#17818" class="Function">cong</a><a name="19638" class="Symbol">;</a><a name="19639"> </a><a name="19640" href="#17708" class="Function">equivalence</a><a name="19651" class="Symbol">)</a><a name="19652">

  </a><a name="19656" href="#19656" class="Function">antisym</a><a name="19663"> </a><a name="19664" class="Symbol">:</a><a name="19665"> </a><a name="19666" class="Symbol">∀</a><a name="19667"> </a><a name="19668" class="Symbol">{</a><a name="19669" href="#19669" class="Bound">x</a><a name="19670"> </a><a name="19671" href="#19671" class="Bound">y</a><a name="19672" class="Symbol">}</a><a name="19673"> </a><a name="19674" class="Symbol">→</a><a name="19675"> </a><a name="19676" href="#19669" class="Bound">x</a><a name="19677"> </a><a name="19678" href="#19042" class="Datatype Operator">≤</a><a name="19679"> </a><a name="19680" href="#19671" class="Bound">y</a><a name="19681"> </a><a name="19682" class="Symbol">→</a><a name="19683"> </a><a name="19684" href="#19671" class="Bound">y</a><a name="19685"> </a><a name="19686" href="#19042" class="Datatype Operator">≤</a><a name="19687"> </a><a name="19688" href="#19669" class="Bound">x</a><a name="19689"> </a><a name="19690" class="Symbol">→</a><a name="19691"> </a><a name="19692" href="#19669" class="Bound">x</a><a name="19693"> </a><a name="19694" href="#15711" class="Datatype Operator">≡</a><a name="19695"> </a><a name="19696" href="#19671" class="Bound">y</a><a name="19697">
  </a><a name="19700" href="#19656" class="Function">antisym</a><a name="19707"> </a><a name="19708" href="#19064" class="InductiveConstructor">z≤n</a><a name="19711">       </a><a name="19718" href="#19064" class="InductiveConstructor">z≤n</a><a name="19721">       </a><a name="19728" class="Symbol">=</a><a name="19729"> </a><a name="19730" href="#15737" class="InductiveConstructor">refl</a><a name="19734">
  </a><a name="19737" href="#19656" class="Function">antisym</a><a name="19744"> </a><a name="19745" class="Symbol">(</a><a name="19746" href="#19093" class="InductiveConstructor">s≤s</a><a name="19749"> </a><a name="19750" href="#19750" class="Bound">x≤y</a><a name="19753" class="Symbol">)</a><a name="19754"> </a><a name="19755" class="Symbol">(</a><a name="19756" href="#19093" class="InductiveConstructor">s≤s</a><a name="19759"> </a><a name="19760" href="#19760" class="Bound">y≤x</a><a name="19763" class="Symbol">)</a><a name="19764"> </a><a name="19765" class="Symbol">=</a><a name="19766"> </a><a name="19767" href="#17818" class="Function">cong</a><a name="19771"> </a><a name="19772" href="#18745" class="InductiveConstructor">suc</a><a name="19775"> </a><a name="19776" class="Symbol">(</a><a name="19777" href="#19656" class="Function">antisym</a><a name="19784"> </a><a name="19785" href="#19750" class="Bound">x≤y</a><a name="19788"> </a><a name="19789" href="#19760" class="Bound">y≤x</a><a name="19792" class="Symbol">)</a><a name="19793">

  </a><a name="19797" href="#19797" class="Function">trans</a><a name="19802"> </a><a name="19803" class="Symbol">:</a><a name="19804"> </a><a name="19805" class="Symbol">∀</a><a name="19806"> </a><a name="19807" class="Symbol">{</a><a name="19808" href="#19808" class="Bound">x</a><a name="19809"> </a><a name="19810" href="#19810" class="Bound">y</a><a name="19811"> </a><a name="19812" href="#19812" class="Bound">z</a><a name="19813" class="Symbol">}</a><a name="19814"> </a><a name="19815" class="Symbol">→</a><a name="19816"> </a><a name="19817" href="#19808" class="Bound">x</a><a name="19818"> </a><a name="19819" href="#19042" class="Datatype Operator">≤</a><a name="19820"> </a><a name="19821" href="#19810" class="Bound">y</a><a name="19822"> </a><a name="19823" class="Symbol">→</a><a name="19824"> </a><a name="19825" href="#19810" class="Bound">y</a><a name="19826"> </a><a name="19827" href="#19042" class="Datatype Operator">≤</a><a name="19828"> </a><a name="19829" href="#19812" class="Bound">z</a><a name="19830"> </a><a name="19831" class="Symbol">→</a><a name="19832"> </a><a name="19833" href="#19808" class="Bound">x</a><a name="19834"> </a><a name="19835" href="#19042" class="Datatype Operator">≤</a><a name="19836"> </a><a name="19837" href="#19812" class="Bound">z</a><a name="19838">
  </a><a name="19841" href="#19797" class="Function">trans</a><a name="19846"> </a><a name="19847" href="#19064" class="InductiveConstructor">z≤n</a><a name="19850">       </a><a name="19857" class="Symbol">_</a><a name="19858">         </a><a name="19867" class="Symbol">=</a><a name="19868"> </a><a name="19869" href="#19064" class="InductiveConstructor">z≤n</a><a name="19872">
  </a><a name="19875" href="#19797" class="Function">trans</a><a name="19880"> </a><a name="19881" class="Symbol">(</a><a name="19882" href="#19093" class="InductiveConstructor">s≤s</a><a name="19885"> </a><a name="19886" href="#19886" class="Bound">x≤y</a><a name="19889" class="Symbol">)</a><a name="19890"> </a><a name="19891" class="Symbol">(</a><a name="19892" href="#19093" class="InductiveConstructor">s≤s</a><a name="19895"> </a><a name="19896" href="#19896" class="Bound">y≤z</a><a name="19899" class="Symbol">)</a><a name="19900"> </a><a name="19901" class="Symbol">=</a><a name="19902"> </a><a name="19903" href="#19093" class="InductiveConstructor">s≤s</a><a name="19906"> </a><a name="19907" class="Symbol">(</a><a name="19908" href="#19797" class="Function">trans</a><a name="19913"> </a><a name="19914" href="#19886" class="Bound">x≤y</a><a name="19917"> </a><a name="19918" href="#19896" class="Bound">y≤z</a><a name="19921" class="Symbol">)</a><a name="19922">

  </a><a name="19926" href="#19926" class="Function">total</a><a name="19931"> </a><a name="19932" class="Symbol">:</a><a name="19933"> </a><a name="19934" class="Symbol">∀</a><a name="19935"> </a><a name="19936" href="#19936" class="Bound">x</a><a name="19937"> </a><a name="19938" href="#19938" class="Bound">y</a><a name="19939"> </a><a name="19940" class="Symbol">→</a><a name="19941"> </a><a name="19942" href="#4497" class="Datatype">Either</a><a name="19948"> </a><a name="19949" class="Symbol">(</a><a name="19950" href="#19936" class="Bound">x</a><a name="19951"> </a><a name="19952" href="#19042" class="Datatype Operator">≤</a><a name="19953"> </a><a name="19954" href="#19938" class="Bound">y</a><a name="19955" class="Symbol">)</a><a name="19956"> </a><a name="19957" class="Symbol">(</a><a name="19958" href="#19938" class="Bound">y</a><a name="19959"> </a><a name="19960" href="#19042" class="Datatype Operator">≤</a><a name="19961"> </a><a name="19962" href="#19936" class="Bound">x</a><a name="19963" class="Symbol">)</a><a name="19964">
  </a><a name="19967" href="#19926" class="Function">total</a><a name="19972"> </a><a name="19973" href="#18732" class="InductiveConstructor">zero</a><a name="19977">    </a><a name="19981" class="Symbol">_</a><a name="19982">       </a><a name="19989" class="Symbol">=</a><a name="19990"> </a><a name="19991" href="#4538" class="InductiveConstructor">left</a><a name="19995">  </a><a name="19997" href="#19064" class="InductiveConstructor">z≤n</a><a name="20000">
  </a><a name="20003" href="#19926" class="Function">total</a><a name="20008"> </a><a name="20009" class="Symbol">(</a><a name="20010" href="#18745" class="InductiveConstructor">suc</a><a name="20013"> </a><a name="20014" href="#20014" class="Bound">x</a><a name="20015" class="Symbol">)</a><a name="20016"> </a><a name="20017" href="#18732" class="InductiveConstructor">zero</a><a name="20021">    </a><a name="20025" class="Symbol">=</a><a name="20026"> </a><a name="20027" href="#4563" class="InductiveConstructor">right</a><a name="20032"> </a><a name="20033" href="#19064" class="InductiveConstructor">z≤n</a><a name="20036">
  </a><a name="20039" href="#19926" class="Function">total</a><a name="20044"> </a><a name="20045" class="Symbol">(</a><a name="20046" href="#18745" class="InductiveConstructor">suc</a><a name="20049"> </a><a name="20050" href="#20050" class="Bound">x</a><a name="20051" class="Symbol">)</a><a name="20052"> </a><a name="20053" class="Symbol">(</a><a name="20054" href="#18745" class="InductiveConstructor">suc</a><a name="20057"> </a><a name="20058" href="#20058" class="Bound">y</a><a name="20059" class="Symbol">)</a><a name="20060"> </a><a name="20061" class="Keyword">with</a><a name="20065"> </a><a name="20066" href="#19926" class="Function">total</a><a name="20071"> </a><a name="20072" href="#20050" class="Bound">x</a><a name="20073"> </a><a name="20074" href="#20058" class="Bound">y</a><a name="20075">
  </a><a name="20078" class="Symbol">...</a><a name="20081"> </a><a name="20082" class="Symbol">|</a><a name="20083"> </a><a name="20084" href="#4538" class="InductiveConstructor">left</a><a name="20088">  </a><a name="20090" href="#20090" class="Bound">x≤y</a><a name="20093"> </a><a name="20094" class="Symbol">=</a><a name="20095"> </a><a name="20096" href="#4538" class="InductiveConstructor">left</a><a name="20100">  </a><a name="20102" class="Symbol">(</a><a name="20103" href="#19093" class="InductiveConstructor">s≤s</a><a name="20106"> </a><a name="20107" href="#20090" class="Bound">x≤y</a><a name="20110" class="Symbol">)</a><a name="20111">
  </a><a name="20114" class="Symbol">...</a><a name="20117"> </a><a name="20118" class="Symbol">|</a><a name="20119"> </a><a name="20120" href="#4563" class="InductiveConstructor">right</a><a name="20125"> </a><a name="20126" href="#20126" class="Bound">y≤x</a><a name="20129"> </a><a name="20130" class="Symbol">=</a><a name="20131"> </a><a name="20132" href="#4563" class="InductiveConstructor">right</a><a name="20137"> </a><a name="20138" class="Symbol">(</a><a name="20139" href="#19093" class="InductiveConstructor">s≤s</a><a name="20142"> </a><a name="20143" href="#20126" class="Bound">y≤x</a><a name="20146" class="Symbol">)</a><a name="20147">

  </a><a name="20151" href="#20151" class="Function">reflexive</a><a name="20160"> </a><a name="20161" class="Symbol">:</a><a name="20162"> </a><a name="20163" class="Symbol">∀</a><a name="20164"> </a><a name="20165" class="Symbol">{</a><a name="20166" href="#20166" class="Bound">x</a><a name="20167"> </a><a name="20168" href="#20168" class="Bound">y</a><a name="20169" class="Symbol">}</a><a name="20170"> </a><a name="20171" class="Symbol">→</a><a name="20172"> </a><a name="20173" href="#20166" class="Bound">x</a><a name="20174"> </a><a name="20175" href="#15711" class="Datatype Operator">≡</a><a name="20176"> </a><a name="20177" href="#20168" class="Bound">y</a><a name="20178"> </a><a name="20179" class="Symbol">→</a><a name="20180"> </a><a name="20181" href="#20166" class="Bound">x</a><a name="20182"> </a><a name="20183" href="#19042" class="Datatype Operator">≤</a><a name="20184"> </a><a name="20185" href="#20168" class="Bound">y</a><a name="20186">
  </a><a name="20189" href="#20151" class="Function">reflexive</a><a name="20198"> </a><a name="20199" class="Symbol">{</a><a name="20200" href="#18732" class="InductiveConstructor">zero</a><a name="20204" class="Symbol">}</a><a name="20205">  </a><a name="20207" href="#15737" class="InductiveConstructor">refl</a><a name="20211"> </a><a name="20212" class="Symbol">=</a><a name="20213"> </a><a name="20214" href="#19064" class="InductiveConstructor">z≤n</a><a name="20217">
  </a><a name="20220" href="#20151" class="Function">reflexive</a><a name="20229"> </a><a name="20230" class="Symbol">{</a><a name="20231" href="#18745" class="InductiveConstructor">suc</a><a name="20234"> </a><a name="20235" class="Symbol">_}</a><a name="20237"> </a><a name="20238" href="#15737" class="InductiveConstructor">refl</a><a name="20242"> </a><a name="20243" class="Symbol">=</a><a name="20244"> </a><a name="20245" href="#19093" class="InductiveConstructor">s≤s</a><a name="20248"> </a><a name="20249" class="Symbol">(</a><a name="20250" href="#20151" class="Function">reflexive</a><a name="20259"> </a><a name="20260" href="#15737" class="InductiveConstructor">refl</a><a name="20264" class="Symbol">)</a><a name="20265">

  </a><a name="20269" href="#20269" class="Function">totalOrder</a><a name="20279"> </a><a name="20280" class="Symbol">:</a><a name="20281"> </a><a name="20282" href="#9046" class="Record">TotalOrder</a><a name="20292"> </a><a name="20293" href="#15711" class="Datatype Operator">_≡_</a><a name="20296"> </a><a name="20297" href="#19042" class="Datatype Operator">_≤_</a><a name="20300">
  </a><a name="20303" href="#20269" class="Function">totalOrder</a><a name="20313"> </a><a name="20314" class="Symbol">=</a><a name="20315"> </a><a name="20316" class="Keyword">record</a><a name="20322">
    </a><a name="20327" class="Symbol">{</a><a name="20328"> </a><a name="20329" href="#9114" class="Field">antisym</a><a name="20336">     </a><a name="20341" class="Symbol">=</a><a name="20342"> </a><a name="20343" href="#19656" class="Function">antisym</a><a name="20350">
    </a><a name="20355" class="Symbol">;</a><a name="20356"> </a><a name="20357" href="#9166" class="Field">trans</a><a name="20362">       </a><a name="20369" class="Symbol">=</a><a name="20370"> </a><a name="20371" href="#19797" class="Function">trans</a><a name="20376">
    </a><a name="20381" class="Symbol">;</a><a name="20382"> </a><a name="20383" href="#9218" class="Field">total</a><a name="20388">       </a><a name="20395" class="Symbol">=</a><a name="20396"> </a><a name="20397" href="#19926" class="Function">total</a><a name="20402">
    </a><a name="20407" class="Symbol">;</a><a name="20408"> </a><a name="20409" href="#9271" class="Field">reflexive</a><a name="20418">   </a><a name="20421" class="Symbol">=</a><a name="20422"> </a><a name="20423" href="#20151" class="Function">reflexive</a><a name="20432">
    </a><a name="20437" class="Symbol">;</a><a name="20438"> </a><a name="20439" href="#9315" class="Field">equivalence</a><a name="20450"> </a><a name="20451" class="Symbol">=</a><a name="20452"> </a><a name="20453" href="#17708" class="Function">equivalence</a><a name="20464">
    </a><a name="20469" class="Symbol">}</a><a name="20470">
</a></code></pre>
<p>Finally, we can import the sorting functions. We’re done!</p>
<pre class="Agda"><code><a name="20543" class="Markup"></a><a name="20555">
  </a><a name="20558" class="Keyword">open</a><a name="20562"> </a><a name="20563" href="#9629" class="Module">Sort</a><a name="20567"> </a><a name="20568" href="#19306" class="Function Operator">_≤?_</a><a name="20572"> </a><a name="20573" href="#20269" class="Function">totalOrder</a><a name="20583"> </a><a name="20584" class="Keyword">using</a><a name="20589"> </a><a name="20590" class="Symbol">(</a><a name="20591">isort</a><a name="20596" class="Symbol">;</a><a name="20597"> treeSort</a><a name="20606" class="Symbol">)</a><a name="20607">
</a></code></pre>
<p>We can test our function:</p>
<pre class="Agda"><code><a name="20647" class="Markup"></a><a name="20659">
  </a><a name="20662" href="#20662" class="Function">willIBeSorted?</a><a name="20676"> </a><a name="20677" class="Symbol">:</a><a name="20678"> </a><a name="20679" href="#2675" class="Datatype">List</a><a name="20683"> </a><a name="20684" href="#18714" class="Datatype">ℕ</a><a name="20685">
  </a><a name="20688" href="#20662" class="Function">willIBeSorted?</a><a name="20702"> </a><a name="20703" class="Symbol">=</a><a name="20704"> </a><a name="20705" href="#15310" class="Function">treeSort</a><a name="20713"> </a><a name="20714" class="Symbol">(</a><a name="20715" class="Number">12</a><a name="20717"> </a><a name="20718" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20719"> </a><a name="20720" class="Number">3</a><a name="20721"> </a><a name="20722" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20723"> </a><a name="20724" class="Number">7</a><a name="20725"> </a><a name="20726" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20727"> </a><a name="20728" class="Number">4</a><a name="20729"> </a><a name="20730" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20731"> </a><a name="20732" class="Number">40</a><a name="20734"> </a><a name="20735" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20736"> </a><a name="20737" class="Number">5</a><a name="20738"> </a><a name="20739" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20740"> </a><a name="20741" class="Number">0</a><a name="20742"> </a><a name="20743" href="#2719" class="InductiveConstructor Operator">∷</a><a name="20744"> </a><a name="20745" href="#2704" class="InductiveConstructor">[]</a><a name="20747" class="Symbol">)</a><a name="20748">
</a></code></pre>
<p>A tap on <code>C-c C-n willIBeSorted?</code> will give the expected result:</p>
<pre class="sourceCode"><code>0 ∷ 3 ∷ 4 ∷ 5 ∷ 7 ∷ 12 ∷ 40 ∷ []</code></pre>
<h2 id="comments">Comments? <a href="#comments" class="section-link">#</a></h2>
<p>This is my first decently-sized blog post, so please complain on <a href="http://www.reddit.com/r/haskell/comments/1biasi/sorting_with_agda/">Reddit</a>!</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol start="1">
<li id="fn1" role="doc-endnote"><p>For the interested, the logical core of most of said systems is an <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory#Extensional_versus_intensional">intensional</a> <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory">Intuitionistic Type Theory</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Specifically:</p>
<ul>
<li>Functions must be <em>structurally recursive</em>, where the arguments in the recursive calls are decreasing.</li>
<li>Disallows data type declarations that are not <em>strictly positive</em>, for example the infamous <code>data Mu f = Mu (f (Mu f))</code> in Haskell.</li>
<li>Has a hierarchy of types—more on this later.</li>
</ul>
<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn3" role="doc-endnote"><p>In type theory this is known as Girards’ paradox, you can find an Agda (with <code>Set : Set</code> enabled) rendition <a href="http://code.haskell.org/Agda/test/succeed/Hurkens.agda">here</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Some might ask why Agda doesn’t treat all parameters uniformly, simply allowing indices at will. This is definitely an option (taken by other programming languages, and GHC’s GADTs) but separating them brings more clarity in the interface and lets Agda deal with inductive families more straightforwardly.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Some might rightfully complain that actually we are only proving half of the story, since we need to guarantee that the result list is a permutation of the input list to prove a sorting algorithm correct. That is doable but a bit more involved.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>For example partial applications are expanded, so that if <code>f : A -&gt; B</code>, then <code>f ≡ λ x → f x</code>. Similary, if we have a record <code>Tuple (A B : Set) : Set</code> with fields <code>fst : A</code> and <code>snd : B</code>, and constructor <code>_,_</code>; if <code>x : Tuple A B</code> then <code>x ≡ fst x , snd x</code>. Apart from these <em>η laws</em>, other additions can be made to have more terms deemed as equal by the type checker, details vary from system to system.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>This is the reason why we did not just use <code>≡</code> from the beginning and we instead chose to parametrise our equality relation: sometimes propositional equality does not cut it, for example when working with functions.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
